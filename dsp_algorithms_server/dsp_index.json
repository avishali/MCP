[
  {
    "algorithm_name": "Main",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#include <mdsp_ui/Theme.h>\n#include <mdsp_ui/FocusRing.h>\n#include <mdsp_ui/AxisRenderer.h>\n#include <mdsp_ui/AxisInteraction.h>\n#include <mdsp_ui/MarkerRenderer.h>\n#include <mdsp_ui/PlotFrameRenderer.h>\n#include <mdsp_ui/SeriesRenderer.h>\n#include <mdsp_ui/BarsRenderer.h>\n#include <mdsp_ui/TextOverlayRenderer.h>\n#include <mdsp_ui/LegendRenderer.h>\n#include <mdsp_ui/AreaFillRenderer.h>\n#include <mdsp_ui/ValueReadoutRenderer.h>\n#include <mdsp_ui/ScaleLabelRenderer.h>\n#include <mdsp_ui/CursorReadoutRenderer.h>\n#include <mdsp_ui/AxisHoverController.h>\n#include <mdsp_ui/HoverPairController.h>\n#include <mdsp_ui/PeakSnapController.h>\n#include <mdsp_ui/AreaFillRenderer.h>\n#include <mdsp_dsp/Smoother.h>\n#include <mdsp_dsp/MeterBallistics.h>\n#include <mdsp_core/Version.h>\n#include <iostream>\n#include <juce_graphics/juce_graphics.h>\n\n/**\n * Minimal smoke test to verify mdsp_ui and mdsp_dsp compile and link correctly.\n * This does not require audio device initialization or GUI windows.\n */\nint main(int argc, char* argv[])\n{\n    std::cout << \"mdsp_smoke_test: Verifying shared modules compile and link...\" << std::endl;\n    \n    // Test mdsp_core\n    std::cout << \"mdsp_core version: \" << mdsp::versionString() << std::endl;\n    \n    // Test mdsp_ui - instantiate Theme and FocusRing\n    mdsp_ui::Theme theme;\n    std::cout << \"mdsp_ui::Theme instantiated\" << std::endl;\n    \n    // Note: FocusRing requires JUCE Component, so we'll just verify the header compiles\n    // In a real scenario, this would be used within a JUCE application\n    std::cout << \"mdsp_ui::FocusRing header verified\" << std::endl;\n    \n    // Test mdsp_ui::AxisRenderer - exercise all four edges with mixed major/minor ticks\n    {\n        juce::Image image (juce::Image::ARGB, 300, 200, true);\n        juce::Graphics g (image);\n        \n        const juce::Rectangle<int> plotBounds (50, 30, 200, 140);\n        const float plotWidth = static_cast<float> (plotBounds.getWidth());\n        const float plotHeight = static_cas"
  },
  {
    "algorithm_name": "CMakeCXXCompilerId",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DE"
  },
  {
    "algorithm_name": "CMakeCXXCompilerId",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DE"
  },
  {
    "algorithm_name": "Smoother",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\n#include <juce_dsp/juce_dsp.h>\n\nnamespace mdsp_dsp\n{\n/**\n * @brief Wrapper around juce::SmoothedValue with consistent setup\n * \n * Provides a stable API for parameter smoothing with time-based initialization.\n */\ntemplate <typename FloatType>\nclass Smoother\n{\npublic:\n    /**\n     * @brief Default constructor\n     */\n    Smoother() = default;\n\n    /**\n     * @brief Constructor with sample rate and smoothing time\n     * @param sampleRate Sample rate in Hz\n     * @param timeMs Smoothing time in milliseconds\n     */\n    Smoother(double sampleRate, double timeMs)\n    {\n        reset(sampleRate, timeMs);\n    }\n\n    /**\n     * @brief Reset with new sample rate and smoothing time\n     * @param sampleRate Sample rate in Hz\n     * @param timeMs Smoothing time in milliseconds\n     */\n    void reset(double sampleRate, double timeMs)\n    {\n        const double timeSeconds = timeMs / 1000.0;\n        smoothedValue.reset(sampleRate, timeSeconds);\n    }\n\n    /**\n     * @brief Set current and target value (no smoothing)\n     */\n    void setCurrentAndTargetValue(FloatType value)\n    {\n        smoothedValue.setCurrentAndTargetValue(value);\n    }\n\n    /**\n     * @brief Set target value (will smooth to this)\n     */\n    void setTargetValue(FloatType value)\n    {\n        smoothedValue.setTargetValue(value);\n    }\n\n    /**\n     * @brief Get next smoothed value (advances internal state)\n     */\n    FloatType getNextValue()\n    {\n        return smoothedValue.getNextValue();\n    }\n\n    /**\n     * @brief Get current smoothed value (doesn't advance state)\n     */\n    FloatType getCurrentValue() const\n    {\n        return smoothedValue.getCurrentValue();\n    }\n\n    /**\n     * @brief Check if currently smoothing\n     */\n    bool isSmoothing() const\n    {\n        return smoothedValue.isSmoothing();\n    }\n\nprivate:\n    juce::SmoothedValue<FloatType, juce::ValueSmoothingTypes::Linear> smoothedValue;\n};\n}\n"
  },
  {
    "algorithm_name": "MeterBallistics",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\n#include <juce_core/juce_core.h>\n#include <cmath>\n\nnamespace mdsp_dsp\n{\n/**\n * @brief Attack/release envelope follower for meter ballistics\n * \n * Provides attack and release time constants suitable for audio level metering displays.\n */\nclass MeterBallistics\n{\npublic:\n    /**\n     * @brief Default constructor\n     */\n    MeterBallistics() = default;\n\n    /**\n     * @brief Constructor with sample rate and time constants\n     * @param sampleRate Sample rate in Hz\n     * @param attackMs Attack time in milliseconds\n     * @param releaseMs Release time in milliseconds\n     */\n    MeterBallistics(double sampleRate, double attackMs, double releaseMs)\n    {\n        reset(sampleRate, attackMs, releaseMs);\n    }\n\n    /**\n     * @brief Reset with new sample rate and time constants\n     * @param sampleRate Sample rate in Hz\n     * @param attackMs Attack time in milliseconds\n     * @param releaseMs Release time in milliseconds\n     * @param initial Initial value (default: 0.0)\n     */\n    void reset(double sampleRate, double attackMs, double releaseMs, float initial = 0.0f)\n    {\n        if (sampleRate > 0.0 && attackMs > 0.0)\n        {\n            const double attackSeconds = attackMs / 1000.0;\n            attackCoeff = static_cast<float>(std::exp(-1.0 / (attackSeconds * sampleRate)));\n        }\n        else\n        {\n            attackCoeff = 0.0f;\n        }\n\n        if (sampleRate > 0.0 && releaseMs > 0.0)\n        {\n            const double releaseSeconds = releaseMs / 1000.0;\n            releaseCoeff = static_cast<float>(std::exp(-1.0 / (releaseSeconds * sampleRate)));\n        }\n        else\n        {\n            releaseCoeff = 0.0f;\n        }\n\n        currentLevel = initial;\n    }\n\n    /**\n     * @brief Process a sample and update the envelope\n     * @param x Input sample value (typically absolute value or squared)\n     * @return Current envelope level\n     */\n    float process(float x) noexcept\n    {\n        if (x > currentLevel)\n        {\n            // Atta"
  },
  {
    "algorithm_name": "Smoother",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#include <mdsp_dsp/Smoother.h>\n"
  },
  {
    "algorithm_name": "MeterBallistics",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#include <mdsp_dsp/MeterBallistics.h>\n"
  },
  {
    "algorithm_name": "Version",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\nnamespace mdsp\n{\ninline constexpr const char* versionString() noexcept { return \"0.1.0\"; }\n}\n"
  },
  {
    "algorithm_name": "Assert",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\n\n#include <cassert>\n\n/**\n * @brief Assertion macro wrapper\n * \n * In debug builds, triggers assertion failure if condition is false.\n * In release builds, condition is evaluated but assertion is disabled.\n */\n#define MDSP_ASSERT(condition) assert(condition)\n\n/**\n * @brief Assertion macro with message\n */\n#define MDSP_ASSERT_MSG(condition, message) assert((condition) && (message))\n"
  },
  {
    "algorithm_name": "AudioBufferQueue",
    "processing_domain": "TimeDomain",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\n\n#include <juce_core/juce_core.h>\n#include <juce_audio_basics/juce_audio_basics.h>\n\nnamespace mdsp\n{\nnamespace core\n{\n//==============================================================================\n/**\n    Lock-free queue that passes mono audio samples from the audio thread\n    (processBlock) to the message thread for spectrum visualization.\n    Uses juce::AbstractFifo for single-producer, single-consumer safe access.\n*/\nclass AudioBufferQueue\n{\npublic:\n    explicit AudioBufferQueue (int capacitySamples);\n    ~AudioBufferQueue() = default;\n\n    /** Pushes mono samples from the audio thread. Mixes L+R if stereo. */\n    void push (const juce::AudioBuffer<float>& buffer, int channelLeft, int channelRight);\n\n    /** Pushes mono float samples (e.g. one channel). Call from audio thread only. */\n    void push (const float* data, int numSamples);\n\n    /** Returns number of samples currently available to read. */\n    int getNumReady() const noexcept { return fifo_.getNumReady(); }\n\n    /** Reads up to maxSamples into dest. Returns number of samples read. Call from message thread. */\n    int pull (float* dest, int maxSamples);\n\n    /** Capacity in samples (set at construction). */\n    int getCapacity() const noexcept { return fifo_.getTotalSize(); }\n\nprivate:\n    juce::AbstractFifo fifo_;\n    std::vector<float> buffer_;\n\n    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (AudioBufferQueue)\n};\n} // namespace core\n} // namespace mdsp\n"
  },
  {
    "algorithm_name": "CMakeCXXCompilerId",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DE"
  },
  {
    "algorithm_name": "Version",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#include <mdsp_core/Version.h>\n"
  },
  {
    "algorithm_name": "AudioBufferQueue",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#include <mdsp_core/containers/AudioBufferQueue.h>\n\nnamespace mdsp\n{\nnamespace core\n{\n//==============================================================================\nAudioBufferQueue::AudioBufferQueue (int capacitySamples)\n    : fifo_ (capacitySamples),\n      buffer_ (static_cast<size_t> (capacitySamples), 0.0f)\n{\n}\n\nvoid AudioBufferQueue::push (const juce::AudioBuffer<float>& buffer, int channelLeft, int channelRight)\n{\n    const int numSamples = buffer.getNumSamples();\n    if (numSamples <= 0)\n        return;\n\n    const int numCh = buffer.getNumChannels();\n    const bool hasL = channelLeft >= 0 && channelLeft < numCh;\n    const bool hasR = channelRight >= 0 && channelRight < numCh && channelRight != channelLeft;\n\n    if (hasL && hasR)\n    {\n        // Stereo: mix to mono in a temporary then push\n        std::vector<float> mono (static_cast<size_t> (numSamples));\n        const float* L = buffer.getReadPointer (channelLeft);\n        const float* R = buffer.getReadPointer (channelRight);\n        for (int i = 0; i < numSamples; ++i)\n            mono[static_cast<size_t> (i)] = 0.5f * (L[i] + R[i]);\n        push (mono.data(), numSamples);\n    }\n    else if (hasL)\n    {\n        push (buffer.getReadPointer (channelLeft), numSamples);\n    }\n    else if (hasR)\n    {\n        push (buffer.getReadPointer (channelRight), numSamples);\n    }\n}\n\nvoid AudioBufferQueue::push (const float* data, int numSamples)\n{\n    if (data == nullptr || numSamples <= 0)\n        return;\n\n    int start1, block1, start2, block2;\n    fifo_.prepareToWrite (numSamples, start1, block1, start2, block2);\n\n    if (block1 > 0)\n        juce::FloatVectorOperations::copy (buffer_.data() + start1, data, block1);\n    if (block2 > 0)\n        juce::FloatVectorOperations::copy (buffer_.data() + start2, data + block1, block2);\n\n    fifo_.finishedWrite (block1 + block2);\n}\n\nint AudioBufferQueue::pull (float* dest, int maxSamples)\n{\n    if (dest == nullptr || maxSamples <= 0)\n        return 0;\n\n    int start1, block1,"
  },
  {
    "algorithm_name": "SpectrumComponent",
    "processing_domain": "FrequencyDomain",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\n\n#include <juce_gui_basics/juce_gui_basics.h>\n#include <juce_dsp/juce_dsp.h>\n#include <mdsp_core/containers/AudioBufferQueue.h>\n#include <vector>\n\nnamespace mdsp\n{\nnamespace gui\n{\n//==============================================================================\n/**\n    SpectrumComponent displays spectrum (FFT) data.\n    Inherits from juce::Component and juce::Timer for periodic repaint/update.\n\n    The host sets the AudioBufferQueue via setAudioBufferQueue(). On each timer\n    tick the component pulls samples from the queue into a fifo, applies a\n    windowing function, runs FFT, converts to dB, and draws a juce::Path in\n    neon green (logarithmic X-axis).\n\n    Data flow: AudioBufferQueue (audio thread push) -> pull (message thread)\n    -> window -> FFT -> Path -> paint().\n*/\nclass SpectrumComponent : public juce::Component,\n                          private juce::Timer\n{\npublic:\n    /** Visual style for the spectrum curve (gradient fill or stroke). */\n    struct Style\n    {\n        juce::Colour colorTop{ 0xff39ff14 };\n        juce::Colour colorBottom{ 0xff0a2a0e };\n        bool isFilled = true;\n        float lineThickness = 2.0f;\n    };\n\n    static constexpr int fftOrder  = 11;\n    static constexpr int fftSize   = 1 << fftOrder;  // 2048\n    static constexpr int scopeSize = 512;\n\n    SpectrumComponent();\n    ~SpectrumComponent() override;\n\n    void paint (juce::Graphics& g) override;\n\n    /** Sets the audio queue to pull from (message thread). Call from host. */\n    void setAudioBufferQueue (mdsp::core::AudioBufferQueue* queue) noexcept { audioBufferQueue_ = queue; }\n\n    /** Sets the spectrum path to draw (call from message thread). Empty path = no curve. */\n    void setSpectrumPath (const juce::Path& path);\n\n    /** Sets the visual style (gradient colors, filled vs stroke, line thickness). */\n    void setStyle (const Style& newStyle);\n\nprivate:\n    Style style_;\n\n    void timerCallback() override;\n    void pushSamplesIntoFifo (const float* data, int "
  },
  {
    "algorithm_name": "SpectrumComponent",
    "processing_domain": "FrequencyDomain",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#include <mdsp_gui/components/SpectrumComponent.h>\n#include <algorithm>\n#include <cmath>\n\nnamespace mdsp\n{\nnamespace gui\n{\n//==============================================================================\nSpectrumComponent::SpectrumComponent()\n    : forwardFFT_ (fftOrder),\n      window_ (static_cast<size_t> (fftSize), juce::dsp::WindowingFunction<float>::blackmanHarris),\n      fifo_ (static_cast<size_t> (fftSize), 0.0f),\n      fftData_ (static_cast<size_t> (2 * fftSize), 0.0f)\n{\n    startTimerHz (30);\n}\n\nSpectrumComponent::~SpectrumComponent() = default;\n\n//==============================================================================\nvoid SpectrumComponent::setSpectrumPath (const juce::Path& path)\n{\n    const juce::ScopedLock sl (pathLock_);\n    spectrumPath_ = path;\n}\n\nvoid SpectrumComponent::setStyle (const Style& newStyle)\n{\n    style_ = newStyle;\n}\n\nvoid SpectrumComponent::paint (juce::Graphics& g)\n{\n    g.fillAll (juce::Colours::black);\n\n    juce::Path toDraw;\n    {\n        const juce::ScopedLock sl (pathLock_);\n        toDraw = spectrumPath_;\n    }\n\n    if (! toDraw.isEmpty())\n    {\n        const auto bounds = getLocalBounds().toFloat();\n\n        if (style_.isFilled)\n        {\n            juce::Path fillPath = toDraw;\n            fillPath.lineTo (bounds.getRight(), bounds.getBottom());\n            fillPath.lineTo (bounds.getX(), bounds.getBottom());\n            fillPath.closeSubPath();\n\n            juce::ColourGradient gradient (\n                style_.colorTop, 0.0f, 0.0f,\n                style_.colorBottom, 0.0f, bounds.getHeight(),\n                false);\n            g.setFillType (juce::FillType (gradient));\n            g.fillPath (fillPath);\n\n            g.setColour (style_.colorTop);\n            g.strokePath (toDraw, juce::PathStrokeType (style_.lineThickness));\n        }\n        else\n        {\n            g.setColour (style_.colorTop);\n            g.strokePath (toDraw, juce::PathStrokeType (style_.lineThickness));\n        }\n    }\n    else\n    {\n        "
  },
  {
    "algorithm_name": "LegendRenderer",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\n\n#include <juce_graphics/juce_graphics.h>\n\nnamespace mdsp_ui\n{\n    struct Theme;\n\n    /**\n     * @brief Edge/position for legend placement\n     */\n    enum class LegendEdge\n    {\n        TopLeft,\n        TopRight,\n        BottomLeft,\n        BottomRight\n    };\n\n    /**\n     * @brief Single legend item (swatch + label)\n     */\n    struct LegendItem\n    {\n        juce::String label;\n        juce::Colour colour;        // caller supplies theme token (e.g., theme.accent, theme.seriesPeak)\n        bool enabled = true;         // visual dim when false (no interaction)\n    };\n\n    /**\n     * @brief Style configuration for legend rendering\n     */\n    struct LegendStyle\n    {\n        float fontHeightPx = 10.0f;\n        float paddingPx = 6.0f;         // inner padding around items\n        float itemGapPx = 6.0f;         // gap between items horizontally\n        float swatchSizePx = 8.0f;      // square swatch\n        float swatchTextGapPx = 4.0f;   // gap between swatch and text\n        float textAlpha = 0.90f;\n        float disabledAlpha = 0.35f;    // applied when item.enabled=false\n        bool drawFrame = true;          // use PlotFrameRenderer style internally\n        float frameCornerRadiusPx = 4.0f;\n        float frameBorderAlpha = 0.90f;\n        float frameFillAlpha = 0.80f;\n        bool clipToFrame = false;\n    };\n\n    /**\n     * @brief Result statistics from legend rendering\n     */\n    struct LegendResult\n    {\n        juce::Rectangle<float> frameBounds;   // where it drew\n        int itemsDrawn = 0;\n    };\n\n    /**\n     * @brief Renderer for drawing legend overlays (swatch + label items)\n     * \n     * Features:\n     * - Theme-based colours (via explicit colour parameters)\n     * - Optional frame background\n     * - No heap allocations in hot path\n     */\n    class LegendRenderer final\n    {\n    public:\n        /**\n         * @brief Draw legend overlay\n         * \n         * @param g Graphics context\n         * @param plotBounds Plot bounds rectangle"
  },
  {
    "algorithm_name": "Theme",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\n#include <juce_graphics/juce_graphics.h>\n#include \"ThemeVariant.h\"\n\nnamespace mdsp_ui\n{\n\nstruct Theme\n{\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    // Constructors\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    Theme() : Theme (ThemeVariant::Dark) {}  // Default to Dark theme\n    explicit Theme (ThemeVariant variant);\n\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    // Backgrounds\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    juce::Colour background { 0xff121212 };   // Deep dark grey (Material Dark)\n    juce::Colour panel      { 0xff1e1e1e };   // Slightly lighter panel (VS Code style)\n\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    // Grid / guides\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    juce::Colour grid       { 0xff2d2d2d };   // Subtle divider\n    juce::Colour gridMajor  { 0xff404040 };   // Major grid lines\n\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    // Text\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    juce::Colour text       { 0xfff0f0f0 };   // High contrast off-white\n    juce::Colour textMuted  { 0xff8b949e };   // Muted blue-grey\n\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    // Accents / highlights\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    juce::Colour accent     { 0xff3794ff };   // Electric blue (modern primary)\n    juce::Colour seriesPeak { 0xffffb74d };   // Warm Orange for peaks\n    juce::Colour warning    { 0xffffb74d };   // Matches seriesPeak\n    juce::Colour error      { 0xfff85149 };   // Soft Red\n    juce::Colour danger     { 0xfff85149 };   // Alias for error\n    juce::Colour success    { 0xff2ea043 };   // Soft Green\n\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    // UI component colors (extracted from hardcoded values)\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    juce::Colour lightGrey  { 0xffcccccc };   // Neutral light grey\n    juce::Colour grey       { 0xff808080 };   // Mid grey\n    "
  },
  {
    "algorithm_name": "PeakSnapController",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\n\n#include <mdsp_ui/AxisInteraction.h>\n#include <juce_core/juce_core.h>\n#include <cmath>\n\nnamespace mdsp_ui\n{\n\n/**\n * @brief State for peak snap controller\n */\nstruct PeakSnapState\n{\n    bool snappedActive = false;    // true if currently snapped to a peak\n    float snappedXPx = 0.0f;       // snapped X position in pixels\n    float snappedFreqHz = 0.0f;     // snapped frequency in Hz\n    float snappedDb = 0.0f;        // snapped dB value\n    int lockedIndex = -1;           // index of locked peak (-1 if not locked)\n    bool locked = false;            // true if locked to a peak (hysteresis active)\n};\n\n/**\n * @brief Style configuration for peak snap controller\n */\nstruct PeakSnapStyle\n{\n    float snapPx = 8.0f;           // distance threshold to snap to peak\n    float releasePx = 16.0f;       // distance threshold to release (must be > snapPx for hysteresis)\n    float searchRadiusPx = 20.0f;  // search window radius for finding peaks\n    float epsPosPx = 0.5f;         // change detection epsilon (pixels)\n    float epsValue = 0.1f;         // change detection epsilon (units)\n};\n\n/**\n * @brief Controller for peak snapping with hysteresis (sticky peak snap)\n * \n * Snaps cursor to nearest local peak within search radius.\n * Once locked, stays locked until cursor moves beyond releasePx threshold.\n * Uses hysteresis to prevent jitter when peak drifts slightly.\n */\nclass PeakSnapController\n{\npublic:\n    /**\n     * @brief Construct with default style\n     */\n    explicit PeakSnapController (const PeakSnapStyle& style = {});\n\n    /**\n     * @brief Set style configuration\n     */\n    void setStyle (const PeakSnapStyle& style);\n\n    /**\n     * @brief Update from cursor X position and data arrays\n     * @param cursorXPx Cursor X position in pixels (relative to plot left)\n     * @param plotBounds Plot bounds rectangle\n     * @param mapping Axis mapping for frequency->pixel conversion\n     * @param freqHz Array of frequency values (Hz)\n     * @param db Array of dB valu"
  },
  {
    "algorithm_name": "CursorReadoutRenderer",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\n\n#include <juce_graphics/juce_graphics.h>\n#include <mdsp_ui/AxisRenderer.h>\n#include <mdsp_ui/AxisInteraction.h>\n#include <mdsp_ui/AxisHoverController.h>\n#include <optional>\n\nnamespace mdsp_ui\n{\n    struct Theme;\n\n    /**\n     * @brief Edge/position for cursor readout placement\n     */\n    enum class CursorReadoutEdge\n    {\n        TopLeft,\n        TopRight,\n        BottomLeft,\n        BottomRight\n    };\n\n    /**\n     * @brief Value to display in cursor readout\n     */\n    struct CursorReadoutValue\n    {\n        juce::String leftLabel;   // e.g. \"f:\"\n        juce::String rightValue;   // e.g. \"1.00 kHz\"\n        bool enabled = true;\n    };\n\n    /**\n     * @brief Style configuration for cursor readout rendering\n     */\n    struct CursorReadoutStyle\n    {\n        CursorReadoutEdge edge = CursorReadoutEdge::TopRight;\n        float fontHeightPx = 10.0f;\n        float paddingPx = 6.0f;\n        float cornerRadiusPx = 4.0f;\n        float fillAlpha = 0.80f;\n        float borderAlpha = 0.90f;\n        float textAlpha = 1.00f;\n        bool clipToPlot = true;\n        std::optional<juce::Colour> valueColourOverride; // optional override for rightValue colour\n    };\n\n    /**\n     * @brief Result statistics from cursor readout rendering\n     */\n    struct CursorReadoutResult\n    {\n        bool active = false;\n        float snappedPosPx = 0.0f;\n        int snappedTickIndex = -1;\n        juce::Rectangle<float> frameBounds;\n        \n        // 2D readout fields\n        bool hasX = false;\n        bool hasY = false;\n        float xValue = 0.0f;\n        float yValue = 0.0f;\n        int xTickIndex = -1;\n        int yTickIndex = -1;\n    };\n\n    /**\n     * @brief Renderer for drawing axis-aware cursor readouts (snap-to-tick + formatted value)\n     * \n     * Features:\n     * - Axis-aware snapping via AxisInteraction\n     * - Frame + aligned label/value via ValueReadoutRenderer\n     * - Theme-based colours\n     * - No heap allocations in hot path\n     */\n    class CursorReadoutRe"
  },
  {
    "algorithm_name": "HoverPairController",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\n\n#include <mdsp_ui/AxisHoverController.h>\n#include <mdsp_ui/AxisInteraction.h>\n#include <juce_core/juce_core.h>\n\nnamespace mdsp_ui\n{\n\n/**\n * @brief Combined state for 2D hover (x and y axes)\n */\nstruct HoverPairState\n{\n    AxisHoverState x;  // X-axis (typically frequency) hover state\n    AxisHoverState y;  // Y-axis (typically dB) hover state\n    \n    /**\n     * @brief Returns true if either axis has active hover\n     */\n    bool anyActive() const noexcept\n    {\n        return x.active || y.active;\n    }\n    \n    /**\n     * @brief Returns true if both axes have active hover\n     */\n    bool bothActive() const noexcept\n    {\n        return x.active && y.active;\n    }\n};\n\n/**\n * @brief Controller for 2D hover state (composes two AxisHoverController instances)\n * \n * Manages hover state for both X and Y axes simultaneously.\n * Provides change detection to minimize repaints.\n */\nclass HoverPairController\n{\npublic:\n    /**\n     * @brief Construct with default style\n     */\n    explicit HoverPairController (const AxisHoverControllerStyle& style = {});\n\n    /**\n     * @brief Set style configuration for both axes\n     */\n    void setStyle (const AxisHoverControllerStyle& style);\n\n    /**\n     * @brief Update from cursor position in plot coordinates\n     * @param cursorXpx Cursor X position relative to plot left edge (0..plotWidthPx)\n     * @param cursorYpx Cursor Y position relative to plot top edge (0..plotHeightPx)\n     * @param plotWidthPx Plot width in pixels\n     * @param plotHeightPx Plot height in pixels\n     * @param xMapping X-axis mapping configuration\n     * @param xTicks Array of X-axis ticks\n     * @param xSnap X-axis snap options\n     * @param yMapping Y-axis mapping configuration\n     * @param yTicks Array of Y-axis ticks\n     * @param ySnap Y-axis snap options\n     * @return true if state changed enough to repaint\n     */\n    bool updateFromCursorPx (float cursorXpx,\n                              float cursorYpx,\n                              f"
  },
  {
    "algorithm_name": "ThemeVariant",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\n\nnamespace mdsp_ui\n{\n\n/**\n    Theme variant enumeration.\n    Supports Dark and Light themes.\n*/\nenum class ThemeVariant\n{\n    Dark,   // Dark theme (default)\n    Light   // Light theme\n};\n\n} // namespace mdsp_ui\n"
  },
  {
    "algorithm_name": "TextOverlayRenderer",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\n\n#include <juce_graphics/juce_graphics.h>\n#include <optional>\n\nnamespace mdsp_ui\n{\n    struct Theme;\n\n    /**\n     * @brief Edge/position hint for text overlay placement (reserved for future use)\n     */\n    enum class TextEdge\n    {\n        Center,\n        TopLeft,\n        TopRight,\n        BottomLeft,\n        BottomRight\n    };\n\n    /**\n     * @brief Style configuration for text overlay rendering\n     */\n    struct TextOverlayStyle\n    {\n        float alpha = 1.0f;              // clamps [0..1]\n        float paddingPx = 0.0f;          // inset within bounds\n        bool clipToBounds = false;       // optional clip\n        juce::Justification justification = juce::Justification::centred;\n        float fontHeightPx = 10.0f;      // caller sets\n        bool useMuted = false;           // choose theme.text vs theme.textMuted\n        std::optional<juce::Colour> colourOverride;  // if set, use this instead of theme colour\n    };\n\n    /**\n     * @brief Renderer for drawing text overlays consistently\n     * \n     * Features:\n     * - Theme-based colours (or explicit override)\n     * - Caller-provided font sizing\n     * - Optional clipping\n     * - No heap allocations in hot path\n     */\n    class TextOverlayRenderer final\n    {\n    public:\n        /**\n         * @brief Draw text overlay\n         * \n         * @param g Graphics context\n         * @param bounds Bounds rectangle for text (will be reduced by paddingPx)\n         * @param theme Theme (for colours, unless colourOverride is set)\n         * @param text Text to draw\n         * @param style Style configuration\n         */\n        static void draw (\n            juce::Graphics& g,\n            juce::Rectangle<float> bounds,\n            const Theme& theme,\n            const juce::String& text,\n            const TextOverlayStyle& style = {});\n    };\n\n} // namespace mdsp_ui\n"
  },
  {
    "algorithm_name": "Typography",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\n\n#include <juce_graphics/juce_graphics.h>\n\nnamespace mdsp_ui\n{\n\n/**\n    Typography structure for font sizes and styles.\n    All values are font heights in pixels.\n*/\nstruct Typography\n{\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    // Font sizes\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    float titleH = 16.0f;      // Main title (e.g., \"AnalyzerPro\")\n    float sectionTitleH = 14.0f; // Section titles (e.g., \"Analyzer\", \"Display\")\n    float labelH = 12.0f;      // Standard labels\n    float labelSmallH = 10.0f; // Small labels (compact controls)\n    float placeholderH = 12.0f; // Placeholder text\n    float statusH = 11.0f;     // Status text (footer)\n\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    // Helper methods for creating fonts\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    juce::Font titleFont() const\n    {\n        return juce::Font (juce::FontOptions().withHeight (titleH));\n    }\n\n    juce::Font sectionTitleFont() const\n    {\n        return juce::Font (juce::FontOptions().withHeight (sectionTitleH).withStyle (\"bold\"));\n    }\n\n    juce::Font labelFont() const\n    {\n        return juce::Font (juce::FontOptions().withHeight (labelH));\n    }\n\n    juce::Font labelSmallFont() const\n    {\n        return juce::Font (juce::FontOptions().withHeight (labelSmallH));\n    }\n\n    juce::Font placeholderFont() const\n    {\n        return juce::Font (juce::FontOptions().withHeight (placeholderH));\n    }\n\n    juce::Font statusFont() const\n    {\n        return juce::Font (juce::FontOptions().withHeight (statusH));\n    }\n};\n\n} // namespace mdsp_ui\n"
  },
  {
    "algorithm_name": "ScaleLabelRenderer",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\n\n#include <juce_graphics/juce_graphics.h>\n\nnamespace mdsp_ui\n{\n    struct Theme;\n\n    /**\n     * @brief Edge/position for scale label placement\n     */\n    enum class ScaleLabelEdge\n    {\n        Left,\n        Right,\n        Top,\n        Bottom\n    };\n\n    /**\n     * @brief Single scale label (unit/scale text)\n     */\n    struct ScaleLabel\n    {\n        juce::String text;          // e.g. \"Hz\", \"dB\", \"ms\"\n        bool enabled = true;         // allow dimming / hiding\n    };\n\n    /**\n     * @brief Style configuration for scale label rendering\n     */\n    struct ScaleLabelStyle\n    {\n        float fontHeightPx = 10.0f;\n        float alpha = 0.6f;\n        float insetPx = 4.0f;\n        bool rotateForVertical = true;   // Left/Right rotate -90/+90\n        bool clipToPlot = false;\n    };\n\n    /**\n     * @brief Result statistics from scale label rendering\n     */\n    struct ScaleLabelResult\n    {\n        juce::Rectangle<float> boundsUsed;\n    };\n\n    /**\n     * @brief Renderer for drawing scale/unit labels on plot edges\n     * \n     * Features:\n     * - Theme-based colours\n     * - Optional rotation for vertical edges\n     * - Optional clipping\n     * - No heap allocations in hot path\n     */\n    class ScaleLabelRenderer final\n    {\n    public:\n        /**\n         * @brief Draw scale label on plot edge\n         * \n         * @param g Graphics context\n         * @param plotBounds Plot bounds rectangle\n         * @param edge Edge placement (Left, Right, Top, Bottom)\n         * @param label Label to draw\n         * @param style Style configuration\n         * @param theme Theme (for colours)\n         * @return ScaleLabelResult Statistics and bounds used\n         */\n        static ScaleLabelResult draw (\n            juce::Graphics& g,\n            const juce::Rectangle<float>& plotBounds,\n            ScaleLabelEdge edge,\n            const ScaleLabel& label,\n            const ScaleLabelStyle& style,\n            const Theme& theme);\n    };\n\n} // namespace mdsp_ui\n"
  },
  {
    "algorithm_name": "AxisRenderer",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\n\n#include <juce_graphics/juce_graphics.h>\n#include <mdsp_ui/Theme.h>\n\nnamespace mdsp_ui\n{\n\n/**\n * @brief Axis edge location\n */\nenum class AxisEdge\n{\n    Bottom,  // X-axis at bottom\n    Left,    // Y-axis at left\n    Top,     // X-axis at top\n    Right    // Y-axis at right\n};\n\n/**\n * @brief Axis tick mark and label\n */\nstruct AxisTick\n{\n    float posPx = 0.0f;      // Position along the axis, relative to plotBounds top (for Left/Right) or left (for Top/Bottom)\n    juce::String label;      // Empty => tick only\n    bool major = false;      // Optional, can be inferred or caller sets; use for length/alpha if provided\n};\n\n/**\n * @brief Axis rendering style configuration\n */\nstruct AxisStyle\n{\n    float tickAlpha = 0.35f;\n    float labelAlpha = 0.90f;\n    float tickThickness = 1.0f;\n    float labelFontHeight = 10.0f;\n    float labelInsetPx = 6.0f;\n    float minorTickLengthPx = 6.0f;\n    float majorTickLengthPx = 10.0f;\n    bool ticksOnly = false;\n    bool clipTicksToPlot = true;\n};\n\n/**\n * @brief Theme-based axis renderer\n * \n * Draws tick marks and labels along plot axes using mdsp_ui::Theme colors.\n * No tick generation logic - caller provides tick positions and labels.\n */\nclass AxisRenderer\n{\npublic:\n    /**\n     * @brief Draw axis with ticks and labels\n     * @param g Graphics context\n     * @param plotBounds Rectangle bounds of the plot area\n     * @param theme Theme for colors\n     * @param ticks Array of tick marks to draw\n     * @param edge Which edge to draw axis on\n     * @param style Axis style configuration\n     */\n    static void draw (juce::Graphics& g,\n                      const juce::Rectangle<int>& plotBounds,\n                      const Theme& theme,\n                      const juce::Array<AxisTick>& ticks,\n                      AxisEdge edge,\n                      const AxisStyle& style = {});\n};\n\n} // namespace mdsp_ui\n"
  },
  {
    "algorithm_name": "AreaFillRenderer",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\n\n#include <juce_graphics/juce_graphics.h>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n#include <cstddef>\n\nnamespace mdsp_ui\n{\n\n    /**\n     * @brief Style configuration for area fill rendering\n     */\n    struct AreaFillStyle\n    {\n        juce::Colour colour;          // caller passes theme token (e.g., theme.accent)\n        float alpha = 0.25f;          // clamped [0..1], applied on top of colour\n        float baselineY01 = 1.0f;     // baseline in normalized plot space (0=top, 1=bottom)\n        bool closeToBaseline = true;  // true: close polygon to baseline\n        bool clipToPlot = true;\n        bool decimate = true;\n        float minXStepPx = 1.0f;      // used when decimate=true\n        float minYStepPx = 0.25f;\n    };\n\n    /**\n     * @brief Statistics from area fill rendering\n     */\n    struct AreaFillStats\n    {\n        int inputPoints = 0;\n        int outputPoints = 0;\n        bool drew = false;\n    };\n\n    /**\n     * @brief Renderer for drawing filled areas under curves\n     * \n     * Features:\n     * - Filled polygon from series data\n     * - Optional baseline closing\n     * - Decimation support\n     * - Plot clipping\n     * - No heap allocations in hot path\n     */\n    class AreaFillRenderer final\n    {\n    public:\n        /**\n         * @brief Draw filled area from mapping functions\n         * \n         * @param g Graphics context\n         * @param plotBounds Plot bounds rectangle\n         * @param xValues Array of x domain values (e.g., frequencies)\n         * @param yValues Array of y domain values (e.g., dB values)\n         * @param numPoints Number of points\n         * @param xTo01 Mapping function: x domain value -> normalized x [0..1]\n         * @param yTo01 Mapping function: y domain value -> normalized y [0..1]\n         * @param style Style configuration\n         * @return AreaFillStats Statistics about rendering\n         */\n        template <typename XTo01, typename YTo01>\n        static AreaFillStats drawFromMapping "
  },
  {
    "algorithm_name": "ValueReadoutRenderer",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\n\n#include <juce_graphics/juce_graphics.h>\n\nnamespace mdsp_ui\n{\n    struct Theme;\n\n    /**\n     * @brief Edge/position for value readout placement\n     */\n    enum class ValueReadoutEdge\n    {\n        TopLeft,\n        TopRight,\n        BottomLeft,\n        BottomRight\n    };\n\n    /**\n     * @brief Single line in a value readout\n     */\n    struct ValueReadoutLine\n    {\n        juce::String left;   // e.g. \"Fc:\"\n        juce::String right;  // e.g. \"1.23 kHz\"\n        bool enabled = true; // allow greying-out optional lines (like Peak)\n    };\n\n    /**\n     * @brief Style configuration for value readout rendering\n     */\n    struct ValueReadoutStyle\n    {\n        ValueReadoutEdge edge = ValueReadoutEdge::TopRight;\n        float fontHeightPx = 10.0f;\n        float lineGapPx = 2.0f;\n        float paddingPx = 6.0f;\n        float minWidthPx = 110.0f;   // keep stable tooltip width feel\n        float maxWidthPx = 160.0f;   // clamp if too wide\n        bool drawFrame = true;\n        float cornerRadiusPx = 4.0f;\n        float frameFillAlpha = 0.80f;\n        float frameBorderAlpha = 0.90f;\n        float textAlpha = 1.0f;\n        float disabledTextAlpha = 0.55f;\n        bool clipToFrame = false; // optional, default false\n    };\n\n    /**\n     * @brief Result statistics from value readout rendering\n     */\n    struct ValueReadoutResult\n    {\n        juce::Rectangle<float> frameBounds;\n        int numLinesDrawn = 0;\n    };\n\n    /**\n     * @brief Renderer for drawing compact readout panels (frame + multi-line text)\n     * \n     * Features:\n     * - Theme-based colours\n     * - Frame + aligned label/value lines\n     * - Optional clipping\n     * - No heap allocations in hot path\n     */\n    class ValueReadoutRenderer final\n    {\n    public:\n        /**\n         * @brief Draw value readout anchored to plot bounds\n         * \n         * @param g Graphics context\n         * @param plotBounds Plot bounds rectangle (readout anchors to edge)\n         * @param theme Theme (for c"
  },
  {
    "algorithm_name": "FocusRing",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\n#include <juce_gui_basics/juce_gui_basics.h>\n\nnamespace mdsp_ui\n{\nclass FocusRing : public juce::Component\n{\npublic:\n    void setEnabled(bool shouldEnable) { enabled = shouldEnable; repaint(); }\n    void setTargetBounds(juce::Rectangle<int> b) { targetBounds = b; repaint(); }\n\n    void paint(juce::Graphics& g) override\n    {\n        if (!enabled) return;\n        g.setColour(juce::Colours::white.withAlpha(0.35f));\n        g.drawRoundedRectangle(targetBounds.toFloat().reduced(1.0f), 6.0f, 2.0f);\n    }\n\nprivate:\n    bool enabled { true };\n    juce::Rectangle<int> targetBounds;\n};\n}\n"
  },
  {
    "algorithm_name": "GridRenderer",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\n\n#include <juce_graphics/juce_graphics.h>\n#include <mdsp_ui/Theme.h>\n\nnamespace mdsp_ui\n{\n\nstruct GridStyle\n{\n    int   minorSpacingPx = 40;   // distance between minor grid lines\n    int   majorEvery     = 5;    // every N minor lines\n    float minorAlpha     = 0.25f;\n    float majorAlpha     = 0.45f;\n    float thickness      = 1.0f;\n    bool  drawMajor      = true;\n};\n\nclass GridRenderer\n{\npublic:\n    GridRenderer() = default;\n    explicit GridRenderer (GridStyle style) : style_ (style) {}\n\n    void draw (juce::Graphics& g,\n               juce::Rectangle<int> bounds,\n               const Theme& theme) const;\n\nprivate:\n    GridStyle style_ {};\n};\n\n} // namespace mdsp_ui"
  },
  {
    "algorithm_name": "MarkerRenderer",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\n\n#include <juce_graphics/juce_graphics.h>\n#include <mdsp_ui/Theme.h>\n\nnamespace mdsp_ui\n{\n\n/**\n * @brief Marker rendering utilities (centerlines, crosshairs, cursor lines, dots)\n * \n * Theme-based marker primitives for consistent UI rendering.\n * No allocations in render calls.\n */\nclass MarkerRenderer\n{\npublic:\n    /**\n     * @brief Draw a centerline (horizontal or vertical) through plot bounds\n     * @param g Graphics context\n     * @param plotBounds Rectangle bounds of the plot area\n     * @param horizontal If true, draw horizontal centerline; if false, vertical\n     * @param theme Theme for colors\n     * @param alpha Alpha value (0.0-1.0)\n     * @param thickness Line thickness\n     * @param clipToPlot If true, clip line to plot bounds\n     */\n    static void drawCenterLine (juce::Graphics& g,\n                                const juce::Rectangle<int>& plotBounds,\n                                bool horizontal,\n                                const Theme& theme,\n                                float alpha = 0.4f,\n                                float thickness = 1.0f,\n                                bool clipToPlot = true) noexcept;\n\n    /**\n     * @brief Draw a crosshair centered at (centerX, centerY)\n     * @param g Graphics context\n     * @param centerX X coordinate of center\n     * @param centerY Y coordinate of center\n     * @param radiusX Horizontal radius (half-width)\n     * @param radiusY Vertical radius (half-height)\n     * @param theme Theme for colors\n     * @param alpha Alpha value (0.0-1.0)\n     * @param thickness Line thickness\n     */\n    static void drawCrosshair (juce::Graphics& g,\n                               float centerX,\n                               float centerY,\n                               float radiusX,\n                               float radiusY,\n                               const Theme& theme,\n                               float alpha = 0.4f,\n                               float thickness = 1.0f) noexcept;\n\n    /"
  },
  {
    "algorithm_name": "SeriesRenderer",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\n\n#include <juce_graphics/juce_graphics.h>\n#include <mdsp_ui/Theme.h>\n#include <algorithm>\n#include <cmath>\n\nnamespace mdsp_ui\n{\n\n/**\n * @brief Decimation mode for series rendering\n */\nenum class DecimationMode\n{\n    Simple,     // Simple pixel-based decimation (default)\n    Envelope    // Preserve min/max per pixel bucket (for dense series)\n};\n\n/**\n * @brief Series rendering style configuration\n */\nstruct SeriesStyle\n{\n    float strokeThickness = 1.5f;\n    float alpha = 1.0f;                 // clamps [0..1]\n    bool clipToPlot = true;\n    bool useRoundedJoins = true;        // map to PathStrokeType join/cap\n    float minXStepPx = 1.0f;            // decimation: minimum horizontal pixel delta before adding a point\n    float minYStepPx = 0.5f;            // optional: add point if y changes enough even if x is similar\n    int maxPointsHint = 0;              // optional hint for caller; SeriesRenderer must not allocate based on this\n    \n    // Envelope decimator settings\n    DecimationMode decimationMode { DecimationMode::Simple };\n    float envelopeMinBucketPx { 1.0f };  // pixel width of bucket (>=1)\n    bool envelopeDrawVertical { true };  // draw min->max segment per bucket\n};\n\n/**\n * @brief Series rendering statistics (optional, for debug)\n */\nstruct SeriesStats\n{\n    int inputPoints = 0;\n    int outputPoints = 0;\n};\n\n/**\n * @brief Series renderer (decimated series stroke + clip)\n * \n * Theme-based series rendering for consistent UI plots.\n * Supports point decimation and clipping to plot bounds.\n * No allocations in render calls.\n */\nclass SeriesRenderer\n{\npublic:\n    /**\n     * @brief Draw a series from an array of points\n     * @param g Graphics context\n     * @param plot Plot bounds rectangle\n     * @param theme Theme (for consistency; colour is passed explicitly)\n     * @param points Array of (x, y) points\n     * @param colour Stroke colour\n     * @param style Series style configuration\n     * @return Statistics (optional, for debug)\n     */\n   "
  },
  {
    "algorithm_name": "BarsRenderer",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\n\n#include <juce_graphics/juce_graphics.h>\n\nnamespace mdsp_ui\n{\n    struct Theme;\n\n    /**\n     * @brief Direction for bar rendering\n     */\n    enum class BarDirection\n    {\n        UpFromBaseline,      // Bar extends upward from baseline (positive values)\n        DownFromBaseline     // Bar extends downward from baseline (negative values)\n    };\n\n    /**\n     * @brief Style configuration for bar series rendering\n     */\n    struct BarsStyle\n    {\n        float fillAlpha = 1.0f;\n        float strokeAlpha = 0.0f;           // optional outline (0 = disabled)\n        float strokeThickness = 1.0f;\n        bool clipToPlot = true;\n        bool drawCaps = false;\n        float capThickness = 1.5f;\n        float capWidthPx = 6.0f;            // half-width centered at bar mid\n        float minBarWidthPx = 1.0f;         // avoid disappearing bars\n    };\n\n    /**\n     * @brief Result statistics from bar rendering\n     */\n    struct BarsResult\n    {\n        int barsDrawn = 0;\n        int capsDrawn = 0;\n    };\n\n    /**\n     * @brief Renderer for drawing bar series (filled rectangles) with optional caps\n     * \n     * Features:\n     * - Clip-to-plot bounds\n     * - Optional cap markers (peak hold as horizontal line at bar top)\n     * - No heap allocations in hot paths\n     * - Theme-based colors (via explicit colour parameters)\n     */\n    class BarsRenderer final\n    {\n    public:\n        /**\n         * @brief Draw bars without caps\n         * \n         * @param g Graphics context\n         * @param plotBounds Plot bounds rectangle (for clipping)\n         * @param theme Theme (for reference, but colours are explicit parameters)\n         * @param xLeftPx Array of left X positions (pixels)\n         * @param xRightPx Array of right X positions (pixels)\n         * @param yTopPx Array of top Y positions (pixels, bar extends to baselineYPx)\n         * @param count Number of bars\n         * @param baselineYPx Baseline Y position (bottom of bars)\n         * @param fillColour "
  },
  {
    "algorithm_name": "UiContext",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\n\n#include \"Theme.h\"\n#include \"Metrics.h\"\n#include \"Typography.h\"\n#include \"ThemeVariant.h\"\n\nnamespace mdsp_ui\n{\n\n/**\n    UiContext provides a central point of access for UI theme, metrics, and typography.\n    This allows for easy theme switching and consistent UI across components.\n*/\nclass UiContext\n{\npublic:\n    explicit UiContext (ThemeVariant variant = ThemeVariant::Dark);\n    \n    const Theme& theme() const noexcept { return theme_; }\n    const Metrics& metrics() const noexcept { return metrics_; }\n    const Typography& type() const noexcept { return typography_; }\n    \n    ThemeVariant getVariant() const noexcept { return variant_; }\n    void setVariant (ThemeVariant variant);\n\nprivate:\n    ThemeVariant variant_;\n    Theme theme_;\n    Metrics metrics_;\n    Typography typography_;\n};\n\n} // namespace mdsp_ui\n"
  },
  {
    "algorithm_name": "Metrics",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\n\nnamespace mdsp_ui\n{\n\n/**\n    Metrics structure for layout constants.\n    All values are in pixels.\n*/\nstruct Metrics\n{\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    // Padding / spacing\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    // Padding / spacing\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    int pad = 12;           // Standard padding (12px = 3x4)\n    int padSmall = 4;       // Small padding (4px = 1x4)\n    int gap = 8;            // Standard gap (8px = 2x4)\n    int gapSmall = 4;       // Small gap (4px = 1x4)\n    int gapTiny = 2;        // Tiny gap (2px = 0.5x4)\n    int sectionSpacing = 16;// Spacing between sections (16px = 4x4)\n\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    // Component sizes\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    int titleHeight = 16;      // Section title height\n    int secondaryHeight = 12;  // Secondary label height\n    int buttonH = 24;          // Standard button height (24px)\n    int buttonW = 80;          // Standard button width\n    int buttonSmallH = 16;     // Small button height\n    int buttonSmallW = 48;     // Small button width\n    int comboH = 20;           // Combo box height\n    int comboStandardH = 24;   // Standard combo height\n    int sliderH = 16;          // Slider height\n    int sliderStandardH = 20;  // Standard slider height\n    int sliderTextBoxW = 40;   // Slider text box width\n    int sliderTextBoxH = 16;   // Slider text box height\n\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    // Layout gaps\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    int titleSecondaryGap = 4;  // Gap between title and secondary label\n\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    // Header-specific metrics\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    int headerButtonW = 80;\n    int headerButtonH = 24;\n    int headerDbRangeLabelW = 60;\n    int headerDbRangeBoxW = 90;\n  "
  },
  {
    "algorithm_name": "PlotFrameRenderer",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\n\n#include <juce_graphics/juce_graphics.h>\n#include <mdsp_ui/Theme.h>\n\nnamespace mdsp_ui\n{\n\n/**\n * @brief Plot frame rendering style configuration\n */\nstruct PlotFrameStyle\n{\n    float cornerRadiusPx = 6.0f;        // rounded corners\n    float borderThicknessPx = 1.0f;     // border stroke\n    float borderAlpha = 0.55f;          // border opacity\n    float fillAlpha = 1.0f;             // panel fill opacity\n    float innerStrokeThicknessPx = 0.0f;// optional inner stroke\n    float innerStrokeAlpha = 0.0f;      // optional inner stroke opacity\n    float insetPx = 0.0f;               // shrink bounds before drawing\n    bool  drawFill = true;\n    bool  drawBorder = true;\n    bool  clipToFrame = false;          // optionally clip subsequent drawing to inside\n};\n\n/**\n * @brief Plot frame rendering result (computed rects)\n */\nstruct PlotFrameResult\n{\n    juce::Rectangle<float> frame;       // frame rect (after inset)\n    juce::Rectangle<float> inner;       // inner rect (after border/inset)\n};\n\n/**\n * @brief Plot frame renderer (panel + border + optional clip)\n * \n * Theme-based plot frame rendering for consistent UI panels.\n * No allocations in render calls.\n */\nclass PlotFrameRenderer\n{\npublic:\n    /**\n     * @brief Draws a plot \"panel\": background fill + border; optionally sets clip.\n     * @param g Graphics context\n     * @param bounds Rectangle bounds (will be inset by style.insetPx)\n     * @param theme Theme for colors\n     * @param style Frame style configuration\n     * @return Computed frame + inner content rects for downstream rendering\n     */\n    static PlotFrameResult draw (juce::Graphics& g,\n                                 juce::Rectangle<float> bounds,\n                                 const Theme& theme,\n                                 const PlotFrameStyle& style = {});\n};\n\n} // namespace mdsp_ui\n"
  },
  {
    "algorithm_name": "AxisHoverController",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\n\n#include <mdsp_ui/AxisInteraction.h>\n#include <juce_core/juce_core.h>\n#include <cmath>\n\nnamespace mdsp_ui\n{\n\n/**\n * @brief Hover state for axis interaction\n */\nstruct AxisHoverState\n{\n    bool active = false;              // true if hover is active (inside plot)\n    float cursorPosPx = 0.0f;          // cursor position along axis in pixels (0..axisLengthPx)\n    float value = 0.0f;                // mapped value (Hz, dB, etc)\n    int snappedTickIndex = -1;         // -1 if not snapped\n};\n\n/**\n * @brief Style configuration for axis hover controller\n */\nstruct AxisHoverControllerStyle\n{\n    AxisSnapOptions snap;              // the canonical snap config\n    float epsPosPx = 0.5f;             // change detection epsilon (pixels)\n    float epsValue = 0.1f;             // change detection epsilon (units; caller sets appropriately)\n};\n\n/**\n * @brief Controller for axis hover state and snapping policy\n * \n * Consolidates hover state management and snapping decisions.\n * Uses AxisInteraction for hit testing and provides change detection\n * to minimize repaints.\n */\nclass AxisHoverController\n{\npublic:\n    /**\n     * @brief Construct with default style\n     */\n    explicit AxisHoverController (const AxisHoverControllerStyle& style = {});\n\n    /**\n     * @brief Set style configuration\n     */\n    void setStyle (const AxisHoverControllerStyle& style);\n\n    /**\n     * @brief Update from a cursor position in plot coordinates\n     * @param cursorPosPx Cursor position along axis in pixels (will be clamped to [0..axisLengthPx])\n     * @param axisLengthPx Length of axis in pixels\n     * @param mapping Axis mapping configuration\n     * @param ticks Array of axis ticks\n     * @return true if state changed enough to repaint\n     */\n    bool updateFromCursorPx (float cursorPosPx,\n                             float axisLengthPx,\n                             const AxisMapping& mapping,\n                             const juce::Array<AxisTick>& ticks);\n\n    /**\n     * @brief Dea"
  },
  {
    "algorithm_name": "AxisInteraction",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\n\n#include <juce_graphics/juce_graphics.h>\n#include <mdsp_ui/AxisRenderer.h>\n\nnamespace mdsp_ui\n{\n\n/**\n * @brief Axis scale type\n */\nenum class AxisScale\n{\n    Linear,\n    Log10\n};\n\n/**\n * @brief Snap mode for axis hover\n */\nenum class SnapMode\n{\n    None,\n    NearestTick,\n    NearestLabelledTick\n};\n\n/**\n * @brief Axis mapping configuration\n */\nstruct AxisMapping\n{\n    AxisScale scale = AxisScale::Linear;\n    float minValue = 0.0f;\n    float maxValue = 1.0f;\n    // NOTE: for log scale, minValue > 0 and maxValue > minValue\n};\n\n/**\n * @brief Hit test result for axis interaction\n */\nstruct AxisHitTest\n{\n    bool active = false;         // true if hover is active (inside plot)\n    bool insidePlot = false;     // true if posPx is within plot bounds\n    float value = 0.0f;          // value at cursor (unsnapped)\n    float snappedValue = 0.0f;    // value after snapping (or same as value if not snapped)\n    int tickIndex = -1;          // index into provided ticks after snapping, or -1\n    float tickPosPx = 0.0f;      // snapped tick position in px offset from plot edge, or 0\n    float posPx = 0.0f;         // resolved position (snapped if snapped, else raw posPx)\n    juce::String label;         // resolved label if snapped to a tick, otherwise empty\n    bool snapped = false;        // true if snapped to a tick\n};\n\n/**\n * @brief Snap options for axis interaction\n */\nstruct AxisSnapOptions\n{\n    SnapMode mode = SnapMode::NearestLabelledTick;\n    float maxSnapDistPx = 10.0f; // if nearest tick farther than this, no snap\n};\n\n/**\n * @brief Axis interaction utilities (hover, snapping, readout)\n * \n * Pure stateless functions for converting between pixel positions and axis values,\n * and for hit-testing with optional snapping to ticks.\n */\nclass AxisInteraction\n{\npublic:\n    /**\n     * @brief Convert axis value to pixel position\n     * @param m Axis mapping configuration\n     * @param value Value to convert\n     * @param plotLengthPx Length of plot area in pixels\n   "
  },
  {
    "algorithm_name": "LookAndFeel",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\n\n#include <juce_gui_basics/juce_gui_basics.h>\n#include \"UiContext.h\"\n\nnamespace mdsp_ui\n{\n\n/**\n    Custom LookAndFeel for MelechDSP UI.\n    Implements the visual design system using Theme and Metrics.\n    Focuses on compact, flat, modern aesthetics.\n*/\nclass LookAndFeel : public juce::LookAndFeel_V4\n{\npublic:\n    explicit LookAndFeel (UiContext& ui);\n    ~LookAndFeel() override;\n\n    //==============================================================================\n    // Sliders\n    void drawLinearSlider (juce::Graphics&, int x, int y, int width, int height,\n                           float sliderPos, float minSliderPos, float maxSliderPos,\n                           const juce::Slider::SliderStyle, juce::Slider&) override;\n\n    //==============================================================================\n    // Buttons\n    void drawButtonBackground (juce::Graphics&, juce::Button&, const juce::Colour& backgroundColour,\n                               bool shouldDrawButtonAsHighlighted, bool shouldDrawButtonAsDown) override;\n    \n    void drawToggleButton (juce::Graphics&, juce::ToggleButton&,\n                           bool shouldDrawButtonAsHighlighted, bool shouldDrawButtonAsDown) override;\n\n    //==============================================================================\n    // ComboBox\n    void drawComboBox (juce::Graphics&, int width, int height, bool isButtonDown,\n                       int buttonX, int buttonY, int buttonW, int buttonH,\n                       juce::ComboBox&) override;\n    \n    void positionComboBoxText (juce::ComboBox&, juce::Label&) override;\n    \n    void drawPopupMenuItem (juce::Graphics&, const juce::Rectangle<int>& area,\n                            const bool isSeparator, const bool isActive,\n                            const bool isHighlighted, const bool isTicked,\n                            const bool hasSubMenu, const juce::String& text,\n                            const juce::String& shortcutKeyText,\n              "
  },
  {
    "algorithm_name": "SliderRow",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\n\n#include <juce_gui_basics/juce_gui_basics.h>\n#include <mdsp_ui/UiContext.h>\n\nnamespace mdsp_ui\n{\n\n/**\n    Helper class for label + slider rows.\n    Encapsulates setup and layout of slider controls.\n    \n    Usage:\n        SliderRow row (ui_, \"Label Text\", slider, min, max, step, defaultValue);\n        row.attachToParent (parent);\n        row.layout (bounds, y);\n*/\nclass SliderRow\n{\npublic:\n    SliderRow (UiContext& ui,\n               const juce::String& labelText,\n               juce::Slider& slider,\n               double minValue,\n               double maxValue,\n               double stepValue,\n               double defaultValue);\n    \n    void attachToParent (juce::Component& parent);\n    void layout (juce::Rectangle<int> bounds, int& y);\n    \n    juce::Label& getLabel() { return label_; }\n    juce::Slider& getSlider() { return slider_; }\n\nprivate:\n    UiContext& ui_;\n    juce::Label label_;\n    juce::Slider& slider_;\n};\n\n} // namespace mdsp_ui\n"
  },
  {
    "algorithm_name": "SectionHeader",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\n\n#include <juce_gui_basics/juce_gui_basics.h>\n#include <mdsp_ui/UiContext.h>\n\nnamespace mdsp_ui\n{\n\n/**\n    Helper class for section header labels.\n    Encapsulates setup and layout of section titles.\n    \n    Usage:\n        SectionHeader header (ui_, \"Section Name\");\n        header.attachToParent (parent);\n        header.layout (bounds, y);\n*/\nclass SectionHeader\n{\npublic:\n    explicit SectionHeader (UiContext& ui, const juce::String& text);\n    \n    void attachToParent (juce::Component& parent);\n    void layout (juce::Rectangle<int> bounds, int& y);\n    \n    juce::Label& getLabel() { return label_; }\n\nprivate:\n    UiContext& ui_;\n    juce::Label label_;\n};\n\n} // namespace mdsp_ui\n"
  },
  {
    "algorithm_name": "ChoiceRow",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\n\n#include <juce_gui_basics/juce_gui_basics.h>\n#include <mdsp_ui/UiContext.h>\n\nnamespace mdsp_ui\n{\n\n/**\n    Helper class for label + combo box rows.\n    Encapsulates setup and layout of choice controls.\n    \n    Usage:\n        ChoiceRow row (ui_, \"Label Text\", comboBox);\n        row.attachToParent (parent);\n        row.layout (bounds, y);\n*/\nclass ChoiceRow\n{\npublic:\n    ChoiceRow (UiContext& ui, const juce::String& labelText, juce::ComboBox& combo);\n    \n    void attachToParent (juce::Component& parent);\n    void layout (juce::Rectangle<int> bounds, int& y);\n    \n    juce::Label& getLabel() { return label_; }\n    juce::ComboBox& getCombo() { return combo_; }\n\nprivate:\n    UiContext& ui_;\n    juce::Label label_;\n    juce::ComboBox& combo_;\n};\n\n} // namespace mdsp_ui\n"
  },
  {
    "algorithm_name": "ToggleRow",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\n\n#include <juce_gui_basics/juce_gui_basics.h>\n#include <mdsp_ui/UiContext.h>\n\nnamespace mdsp_ui\n{\n\n/**\n    Helper class for label + toggle button rows.\n    Encapsulates setup and layout of toggle controls.\n    \n    Usage:\n        ToggleRow row (ui_, \"Label Text\", toggleButton);\n        row.attachToParent (parent);\n        row.layout (bounds, y);\n*/\nclass ToggleRow\n{\npublic:\n    ToggleRow (UiContext& ui, const juce::String& labelText, juce::ToggleButton& toggle);\n    \n    void attachToParent (juce::Component& parent);\n    void layout (juce::Rectangle<int> bounds, int& y);\n    \n    juce::Label& getLabel() { return label_; }\n    juce::ToggleButton& getToggle() { return toggle_; }\n\nprivate:\n    UiContext& ui_;\n    juce::Label label_;\n    juce::ToggleButton& toggle_;\n};\n\n} // namespace mdsp_ui\n"
  },
  {
    "algorithm_name": "GridRenderer",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#include <mdsp_ui/GridRenderer.h>\n#include <algorithm>\n\nnamespace mdsp_ui\n{\n\nstatic inline bool isValid (const GridStyle& s) noexcept\n{\n    return s.minorSpacingPx > 0\n        && s.majorEvery > 0\n        && s.thickness > 0.0f;\n}\n\nstatic inline float clampAlpha (float alpha) noexcept\n{\n    return std::clamp (alpha, 0.0f, 1.0f);\n}\n\nvoid GridRenderer::draw (juce::Graphics& g,\n                         juce::Rectangle<int> bounds,\n                         const Theme& theme) const\n{\n    if (bounds.isEmpty() || ! isValid (style_))\n        return;\n\n    const int x0 = bounds.getX();\n    const int y0 = bounds.getY();\n    const int x1 = bounds.getRight();\n    const int y1 = bounds.getBottom();\n    const int w = bounds.getWidth();\n    const int h = bounds.getHeight();\n\n    // ------------------------------\n    // Minor grid\n    // ------------------------------\n    const float minorAlphaClamped = clampAlpha (style_.minorAlpha);\n    g.setColour (theme.grid.withAlpha (minorAlphaClamped));\n\n    for (int x = style_.minorSpacingPx; x < w; x += style_.minorSpacingPx)\n    {\n        const float xPos = static_cast<float> (x0 + x);\n        g.drawLine (xPos, static_cast<float> (y0), xPos, static_cast<float> (y1), style_.thickness);\n    }\n\n    for (int y = style_.minorSpacingPx; y < h; y += style_.minorSpacingPx)\n    {\n        const float yPos = static_cast<float> (y0 + y);\n        g.drawLine (static_cast<float> (x0), yPos, static_cast<float> (x1), yPos, style_.thickness);\n    }\n\n    // ------------------------------\n    // Major grid\n    // ------------------------------\n    if (! style_.drawMajor)\n        return;\n\n    const int majorSpacing = style_.minorSpacingPx * style_.majorEvery;\n    if (majorSpacing <= 0)\n        return;\n\n    const float majorAlphaClamped = clampAlpha (style_.majorAlpha);\n    g.setColour (theme.grid.withAlpha (majorAlphaClamped));\n\n    for (int x = majorSpacing; x < w; x += majorSpacing)\n    {\n        const float xPos = static_cast<float> (x0 + x);\n        g.drawL"
  },
  {
    "algorithm_name": "PeakSnapController",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#include <mdsp_ui/PeakSnapController.h>\n#include <mdsp_ui/AxisInteraction.h>\n#include <algorithm>\n#include <cmath>\n\nnamespace mdsp_ui\n{\n\nPeakSnapController::PeakSnapController (const PeakSnapStyle& style)\n    : style_ (style)\n{\n}\n\nvoid PeakSnapController::setStyle (const PeakSnapStyle& style)\n{\n    style_ = style;\n}\n\nbool PeakSnapController::updateFromCursorX (float cursorXPx,\n                                            const juce::Rectangle<float>& plotBounds,\n                                            const AxisMapping& mapping,\n                                            const float* freqHz,\n                                            const float* db,\n                                            int count)\n{\n    if (count <= 0 || !freqHz || !db || plotBounds.isEmpty())\n    {\n        return deactivate();\n    }\n    \n    // Check if cursor is within plot bounds\n    const float plotLeft = plotBounds.getX();\n    const float plotRight = plotBounds.getRight();\n    if (cursorXPx < plotLeft || cursorXPx > plotRight)\n    {\n        return deactivate();\n    }\n    \n    // Find nearest peak within search radius\n    const int peakIndex = findNearestPeak (cursorXPx, plotBounds, mapping, freqHz, db, count);\n    \n    PeakSnapState newState;\n    newState.snappedActive = (peakIndex >= 0);\n    \n    if (peakIndex >= 0)\n    {\n        // Convert peak frequency to pixel position (relative to plot left)\n        const float peakFreqHz = freqHz[peakIndex];\n        const float peakXPxRel = AxisInteraction::valueToPosPx (mapping, peakFreqHz, plotBounds.getWidth());\n        const float peakXPx = plotBounds.getX() + peakXPxRel;\n        const float peakDb = db[peakIndex];\n        \n        const float distPx = std::abs (cursorXPx - peakXPx);\n        \n        // Check if we should lock/unlock based on hysteresis\n        if (state_.locked && state_.lockedIndex == peakIndex)\n        {\n            // Already locked to this peak - check release threshold\n            if (distPx <= style_.releasePx)\n   "
  },
  {
    "algorithm_name": "AxisInteraction",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#include <mdsp_ui/AxisInteraction.h>\n#include <algorithm>\n#include <cmath>\n\nnamespace mdsp_ui\n{\n\nstatic inline bool isValidMapping (const AxisMapping& m, float plotLengthPx) noexcept\n{\n    if (plotLengthPx <= 0.0f)\n        return false;\n    \n    if (m.scale == AxisScale::Log10)\n    {\n        return m.minValue > 0.0f && m.maxValue > m.minValue;\n    }\n    else // Linear\n    {\n        return m.maxValue > m.minValue;\n    }\n}\n\nfloat AxisInteraction::valueToPosPx (const AxisMapping& m, float value, float plotLengthPx) noexcept\n{\n    if (! isValidMapping (m, plotLengthPx))\n        return 0.0f;\n    \n    // Clamp value to valid range\n    const float clampedValue = std::clamp (value, m.minValue, m.maxValue);\n    \n    if (m.scale == AxisScale::Log10)\n    {\n        const float logMin = std::log10 (m.minValue);\n        const float logMax = std::log10 (m.maxValue);\n        const float logValue = std::log10 (clampedValue);\n        const float logRange = logMax - logMin;\n        \n        if (logRange <= 0.0f)\n            return 0.0f;\n        \n        const float normalized = (logValue - logMin) / logRange;\n        return normalized * plotLengthPx;\n    }\n    else // Linear\n    {\n        const float range = m.maxValue - m.minValue;\n        if (range <= 0.0f)\n            return 0.0f;\n        \n        const float normalized = (clampedValue - m.minValue) / range;\n        return normalized * plotLengthPx;\n    }\n}\n\nfloat AxisInteraction::posPxToValue (const AxisMapping& m, float posPx, float plotLengthPx) noexcept\n{\n    if (! isValidMapping (m, plotLengthPx))\n        return m.minValue;\n    \n    // Clamp posPx to [0..plotLengthPx]\n    const float clampedPosPx = std::clamp (posPx, 0.0f, plotLengthPx);\n    const float normalized = clampedPosPx / plotLengthPx;\n    \n    if (m.scale == AxisScale::Log10)\n    {\n        const float logMin = std::log10 (m.minValue);\n        const float logMax = std::log10 (m.maxValue);\n        const float logRange = logMax - logMin;\n        const float logValue = l"
  },
  {
    "algorithm_name": "ScaleLabelRenderer",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#include <mdsp_ui/ScaleLabelRenderer.h>\n#include <mdsp_ui/Theme.h>\n#include <juce_graphics/juce_graphics.h>\n#include <algorithm>\n#include <cmath>\n\nnamespace mdsp_ui\n{\n\n    ScaleLabelResult ScaleLabelRenderer::draw (\n        juce::Graphics& g,\n        const juce::Rectangle<float>& plotBounds,\n        ScaleLabelEdge edge,\n        const ScaleLabel& label,\n        const ScaleLabelStyle& style,\n        const Theme& theme)\n    {\n        ScaleLabelResult result;\n        \n        if (!label.enabled || label.text.isEmpty() || plotBounds.isEmpty())\n            return result;\n        \n        // Clamp alpha\n        const float alphaClamped = juce::jlimit (0.0f, 1.0f, style.alpha);\n        \n        // Set up clipping if requested\n        juce::Graphics::ScopedSaveState saveState (g);\n        if (style.clipToPlot)\n        {\n            g.reduceClipRegion (plotBounds.toNearestInt());\n        }\n        \n        // Set font\n        const juce::Font font (juce::FontOptions().withHeight (style.fontHeightPx));\n        g.setFont (font);\n        \n        // Measure text width/height using GlyphArrangement\n        juce::GlyphArrangement glyphs;\n        glyphs.addFittedText (font, label.text, 0.0f, 0.0f, 10000.0f, style.fontHeightPx, juce::Justification::centred, 1);\n        const juce::Rectangle<float> textBounds = glyphs.getBoundingBox (0, -1, true);\n        const float textWidth = textBounds.getWidth();\n        const float textHeight = textBounds.getHeight();\n        \n        // Compute label position based on edge\n        float labelX = 0.0f;\n        float labelY = 0.0f;\n        float labelW = textWidth;\n        float labelH = textHeight;\n        juce::Justification justification = juce::Justification::centred;\n        float rotationAngle = 0.0f;\n        \n        switch (edge)\n        {\n            case ScaleLabelEdge::Left:\n                labelX = plotBounds.getX() - style.insetPx - textHeight; // rotated, so height becomes width\n                labelY = plotBounds.getY() + (plotBou"
  },
  {
    "algorithm_name": "LegendRenderer",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#include <mdsp_ui/LegendRenderer.h>\n#include <mdsp_ui/Theme.h>\n#include <mdsp_ui/PlotFrameRenderer.h>\n#include <mdsp_ui/TextOverlayRenderer.h>\n#include <algorithm>\n#include <cmath>\n\nnamespace mdsp_ui\n{\n\n    LegendResult LegendRenderer::draw (\n        juce::Graphics& g,\n        const juce::Rectangle<float>& plotBounds,\n        const Theme& theme,\n        const LegendItem* items,\n        int numItems,\n        LegendEdge edge,\n        const LegendStyle& style)\n    {\n        LegendResult result;\n        \n        if (numItems <= 0 || ! items)\n            return result;\n        \n        // Clamp alphas to [0..1]\n        const float textAlphaClamped = juce::jlimit (0.0f, 1.0f, style.textAlpha);\n        const float disabledAlphaClamped = juce::jlimit (0.0f, 1.0f, style.disabledAlpha);\n        const float frameBorderAlphaClamped = juce::jlimit (0.0f, 1.0f, style.frameBorderAlpha);\n        const float frameFillAlphaClamped = juce::jlimit (0.0f, 1.0f, style.frameFillAlpha);\n        \n        // Measure text widths to compute total width\n        const juce::Font font (juce::FontOptions().withHeight (style.fontHeightPx));\n        g.setFont (font);\n        \n        float totalWidth = 0.0f;\n        int enabledCount = 0;\n        \n        for (int i = 0; i < numItems; ++i)\n        {\n            if (! items[i].enabled)\n                continue;\n            \n            ++enabledCount;\n            // Use GlyphArrangement to measure text width (non-deprecated)\n            juce::GlyphArrangement glyphs;\n            glyphs.addFittedText (font, items[i].label, 0.0f, 0.0f, 10000.0f, style.fontHeightPx, juce::Justification::left, 1);\n            const float textWidth = glyphs.getBoundingBox (0, -1, true).getWidth();\n            totalWidth += style.swatchSizePx + style.swatchTextGapPx + textWidth;\n            \n            if (i < numItems - 1)\n                totalWidth += style.itemGapPx;\n        }\n        \n        // If no enabled items, return empty result\n        if (enabledCount == 0)\n  "
  },
  {
    "algorithm_name": "TextOverlayRenderer",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#include <mdsp_ui/TextOverlayRenderer.h>\n#include <mdsp_ui/Theme.h>\n\nnamespace mdsp_ui\n{\n\n    void TextOverlayRenderer::draw (\n        juce::Graphics& g,\n        juce::Rectangle<float> bounds,\n        const Theme& theme,\n        const juce::String& text,\n        const TextOverlayStyle& style)\n    {\n        if (text.isEmpty())\n            return;\n        \n        // Clamp alpha to [0..1]\n        const float alphaClamped = juce::jlimit (0.0f, 1.0f, style.alpha);\n        \n        // Apply padding by reducing bounds\n        if (style.paddingPx > 0.0f)\n        {\n            bounds = bounds.reduced (style.paddingPx);\n        }\n        \n        // Set up clipping if requested\n        juce::Graphics::ScopedSaveState clipState (g);\n        if (style.clipToBounds)\n        {\n            g.reduceClipRegion (bounds.toNearestInt());\n        }\n        \n        // Determine colour\n        juce::Colour textColour;\n        if (style.colourOverride.has_value())\n        {\n            // Use explicit override (with alpha)\n            textColour = style.colourOverride.value().withAlpha (alphaClamped);\n        }\n        else\n        {\n            // Use theme colour (text or textMuted)\n            const juce::Colour baseColour = style.useMuted ? theme.textMuted : theme.text;\n            textColour = baseColour.withAlpha (alphaClamped);\n        }\n        \n        // Set colour\n        g.setColour (textColour);\n        \n        // Set font using FontOptions (no deprecated ctor)\n        g.setFont (juce::Font (juce::FontOptions().withHeight (style.fontHeightPx)));\n        \n        // Draw text\n        g.drawText (text, bounds.toNearestInt(), style.justification, true);\n    }\n\n} // namespace mdsp_ui\n"
  },
  {
    "algorithm_name": "CursorReadoutRenderer",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#include <mdsp_ui/CursorReadoutRenderer.h>\n#include <mdsp_ui/Theme.h>\n#include <mdsp_ui/AxisInteraction.h>\n#include <mdsp_ui/PlotFrameRenderer.h>\n#include <mdsp_ui/ValueReadoutRenderer.h>\n#include <juce_graphics/juce_graphics.h>\n#include <algorithm>\n#include <cmath>\n#include <array>\n\nnamespace mdsp_ui\n{\n    namespace\n    {\n        constexpr float kInsetPx = 8.0f; // constant inset from plot edge\n    }\n\n    CursorReadoutResult CursorReadoutRenderer::draw (\n        juce::Graphics& g,\n        const juce::Rectangle<int>& plotBounds,\n        const Theme& theme,\n        const juce::Array<AxisTick>& ticks,\n        AxisEdge axisEdge,\n        float cursorPosPx,\n        const AxisMapping& mapping,\n        const AxisSnapOptions& snapOpts,\n        const CursorReadoutValue& value,\n        const CursorReadoutStyle& style)\n    {\n        CursorReadoutResult result;\n        \n        if (!value.enabled || value.rightValue.isEmpty() || plotBounds.isEmpty() || ticks.isEmpty())\n            return result;\n        \n        // Clamp alphas\n        const float fillAlphaClamped = juce::jlimit (0.0f, 1.0f, style.fillAlpha);\n        const float borderAlphaClamped = juce::jlimit (0.0f, 1.0f, style.borderAlpha);\n        const float textAlphaClamped = juce::jlimit (0.0f, 1.0f, style.textAlpha);\n        \n        // Determine axis length\n        const float axisLengthPx = (axisEdge == AxisEdge::Bottom || axisEdge == AxisEdge::Top)\n            ? static_cast<float> (plotBounds.getWidth())\n            : static_cast<float> (plotBounds.getHeight());\n        \n        // Perform hit test and snapping via AxisInteraction\n        const AxisHitTest hit = AxisInteraction::hitTest (cursorPosPx, axisLengthPx, mapping, ticks, snapOpts);\n        \n        result.active = hit.active;\n        result.snappedPosPx = hit.active ? hit.posPx : cursorPosPx;\n        result.snappedTickIndex = hit.tickIndex;\n        \n        // Set up clipping if requested\n        juce::Graphics::ScopedSaveState saveState (g);\n        if (st"
  },
  {
    "algorithm_name": "MarkerRenderer",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#include <mdsp_ui/MarkerRenderer.h>\n#include <algorithm>\n\nnamespace mdsp_ui\n{\n\nvoid MarkerRenderer::drawCenterLine (juce::Graphics& g,\n                                      const juce::Rectangle<int>& plotBounds,\n                                      bool horizontal,\n                                      const Theme& theme,\n                                      float alpha,\n                                      float thickness,\n                                      bool clipToPlot) noexcept\n{\n    if (plotBounds.isEmpty() || thickness <= 0.0f)\n        return;\n\n    const float alphaClamped = clampAlpha (alpha);\n    g.setColour (theme.grid.withAlpha (alphaClamped));\n\n    if (horizontal)\n    {\n        const float y = static_cast<float> (plotBounds.getCentreY());\n        const float x1 = clipToPlot ? static_cast<float> (plotBounds.getX()) : static_cast<float> (plotBounds.getX() - plotBounds.getWidth());\n        const float x2 = clipToPlot ? static_cast<float> (plotBounds.getRight()) : static_cast<float> (plotBounds.getRight() + plotBounds.getWidth());\n        g.drawLine (x1, y, x2, y, thickness);\n    }\n    else\n    {\n        const float x = static_cast<float> (plotBounds.getCentreX());\n        const float y1 = clipToPlot ? static_cast<float> (plotBounds.getY()) : static_cast<float> (plotBounds.getY() - plotBounds.getHeight());\n        const float y2 = clipToPlot ? static_cast<float> (plotBounds.getBottom()) : static_cast<float> (plotBounds.getBottom() + plotBounds.getHeight());\n        g.drawLine (x, y1, x, y2, thickness);\n    }\n}\n\nvoid MarkerRenderer::drawCrosshair (juce::Graphics& g,\n                                     float centerX,\n                                     float centerY,\n                                     float radiusX,\n                                     float radiusY,\n                                     const Theme& theme,\n                                     float alpha,\n                                     float thickness) noexcept\n{\n    if (radi"
  },
  {
    "algorithm_name": "LookAndFeel",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#include \"mdsp_ui/LookAndFeel.h\"\n\nnamespace mdsp_ui\n{\n\nLookAndFeel::LookAndFeel (UiContext& ui)\n    : ui_ (ui)\n{\n    // Initialize default colors from theme\n    const auto& theme = ui_.theme();\n    setColour (juce::Slider::trackColourId, theme.background.brighter (0.1f));\n    setColour (juce::Slider::backgroundColourId, theme.background.darker (0.1f));\n    setColour (juce::Slider::thumbColourId, theme.accent);\n    \n    setColour (juce::ComboBox::backgroundColourId, theme.background.brighter (0.05f));\n    setColour (juce::ComboBox::outlineColourId, theme.borderDivider);\n    setColour (juce::ComboBox::arrowColourId, theme.textMuted);\n    \n    setColour (juce::TextButton::buttonColourId, theme.panel);\n    setColour (juce::TextButton::buttonOnColourId, theme.accent.withAlpha (0.3f));\n    setColour (juce::TextButton::textColourOffId, theme.text);\n    setColour (juce::TextButton::textColourOnId, theme.text);\n}\n\nLookAndFeel::~LookAndFeel() = default;\n\n//==============================================================================\nvoid LookAndFeel::drawLinearSlider (juce::Graphics& g, int x, int y, int width, int height,\n                                    float sliderPos, float minSliderPos, float maxSliderPos,\n                                    const juce::Slider::SliderStyle style, juce::Slider& slider)\n{\n    const auto& theme = ui_.theme();\n    // const auto& metrics = ui_.metrics(); // Unused\n\n    // Only handle horizontal linear for now (used in SliderRow)\n    if (style != juce::Slider::LinearHorizontal)\n    {\n        juce::LookAndFeel_V4::drawLinearSlider (g, x, y, width, height, sliderPos, minSliderPos, maxSliderPos, style, slider);\n        return;\n    }\n\n    const float trackH = 4.0f;\n    const float cy = y + height * 0.5f;\n    \n    juce::Rectangle<float> track (x, cy - trackH * 0.5f, width, trackH);\n\n    // Background track\n    g.setColour (theme.background.darker (0.2f));\n    g.fillRoundedRectangle (track, trackH * 0.5f);\n\n    // Value track\n    juce::Rectangle"
  },
  {
    "algorithm_name": "PlotFrameRenderer",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#include <mdsp_ui/PlotFrameRenderer.h>\n#include <algorithm>\n\nnamespace mdsp_ui\n{\n\nstatic inline float clampAlpha (float alpha) noexcept\n{\n    return std::clamp (alpha, 0.0f, 1.0f);\n}\n\nPlotFrameResult PlotFrameRenderer::draw (juce::Graphics& g,\n                                         juce::Rectangle<float> bounds,\n                                         const Theme& theme,\n                                         const PlotFrameStyle& style)\n{\n    PlotFrameResult result;\n    \n    // Apply inset first\n    juce::Rectangle<float> frame = bounds.reduced (style.insetPx);\n    result.frame = frame;\n    \n    // Guard against empty frame\n    if (frame.isEmpty() || frame.getWidth() <= 0.0f || frame.getHeight() <= 0.0f)\n    {\n        result.inner = frame;\n        return result;\n    }\n    \n    // Compute inner rect (after border)\n    const float borderThickness = std::max (0.0f, style.borderThicknessPx);\n    juce::Rectangle<float> inner = frame.reduced (borderThickness);\n    \n    // Guard against negative inner size\n    if (inner.getWidth() < 0.0f || inner.getHeight() < 0.0f)\n        inner = frame;\n    \n    result.inner = inner;\n    \n    // Draw fill\n    if (style.drawFill)\n    {\n        const float fillAlphaClamped = clampAlpha (style.fillAlpha);\n        g.setColour (theme.panel.withAlpha (fillAlphaClamped));\n        \n        if (style.cornerRadiusPx > 0.0f)\n        {\n            g.fillRoundedRectangle (frame, style.cornerRadiusPx);\n        }\n        else\n        {\n            g.fillRect (frame);\n        }\n    }\n    \n    // Draw border\n    if (style.drawBorder && borderThickness > 0.0f)\n    {\n        const float borderAlphaClamped = clampAlpha (style.borderAlpha);\n        g.setColour (theme.gridMajor.withAlpha (borderAlphaClamped));\n        \n        if (style.cornerRadiusPx > 0.0f)\n        {\n            g.drawRoundedRectangle (frame, style.cornerRadiusPx, borderThickness);\n        }\n        else\n        {\n            g.drawRect (frame, borderThickness);\n        }\n    }\n    \n "
  },
  {
    "algorithm_name": "Theme",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#include <mdsp_ui/Theme.h>\n\nnamespace mdsp_ui\n{\n\nTheme::Theme (ThemeVariant variant)\n{\n    // Initialize theme based on variant\n    // Phase 1: Dark theme only (default values are already dark)\n    // Phase 2 (future): Add Light theme token values\n    \n    if (variant == ThemeVariant::Dark)\n    {\n        // Dark theme (current default values)\n        background = juce::Colour (0xff121212);\n        panel = juce::Colour (0xff1a1a1a);\n        grid = juce::Colour (0xff3a3a3a);\n        gridMajor = juce::Colour (0xff4a4a4a);\n        text = juce::Colour (0xffe6e6e6);\n        textMuted = juce::Colour (0xffb0b0b0);\n        accent = juce::Colour (0xff4fc3f7);\n        seriesPeak = juce::Colour (0xffffc107);\n        warning = juce::Colour (0xffffc107);\n        error = juce::Colour (0xffff5252);\n        danger = juce::Colour (0xffff5252);\n        success = juce::Colour (0xff44ff44);\n        lightGrey = juce::Colour (0xffd3d3d3);\n        grey = juce::Colour (0xff808080);\n        darkGrey = juce::Colour (0xffa9a9a9);\n        black = juce::Colour (0xff000000);\n        transparentBlack = juce::Colour (0x00000000);\n        borderDivider = juce::Colour (0x4d808080);  // darkgrey.withAlpha(0.3f)\n    }\n    else if (variant == ThemeVariant::Light)\n    {\n        // Light theme (placeholder - Phase 2 will implement proper Light tokens)\n        // For now, using inverted dark theme as placeholder\n        // TODO: Replace with actual Light theme tokens from Figma/design system\n        background = juce::Colour (0xfff5f5f5);\n        panel = juce::Colour (0xffffffff);\n        grid = juce::Colour (0xffe0e0e0);\n        gridMajor = juce::Colour (0xffd0d0d0);\n        text = juce::Colour (0xff1a1a1a);\n        textMuted = juce::Colour (0xff606060);\n        accent = juce::Colour (0xff0078d4);  // Adjusted for light background\n        seriesPeak = juce::Colour (0xff0078d4);\n        warning = juce::Colour (0xffd67c00);\n        error = juce::Colour (0xffd13438);\n        danger = juce::Colour (0xffd13438"
  },
  {
    "algorithm_name": "UiContext",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#include <mdsp_ui/UiContext.h>\n\nnamespace mdsp_ui\n{\n\nUiContext::UiContext (ThemeVariant variant)\n    : variant_ (variant),\n      theme_ (variant)\n{\n    // Theme is initialized via constructor parameter\n    // Metrics and Typography use default values (variant-independent for now)\n}\n\nvoid UiContext::setVariant (ThemeVariant variant)\n{\n    if (variant_ != variant)\n    {\n        variant_ = variant;\n        theme_ = Theme (variant);\n        // Future: Notify listeners of theme change (Phase 2)\n    }\n}\n\n} // namespace mdsp_ui\n"
  },
  {
    "algorithm_name": "AxisHoverController",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#include <mdsp_ui/AxisHoverController.h>\n#include <algorithm>\n\nnamespace mdsp_ui\n{\n\nAxisHoverController::AxisHoverController (const AxisHoverControllerStyle& style)\n    : style_ (style)\n{\n}\n\nvoid AxisHoverController::setStyle (const AxisHoverControllerStyle& style)\n{\n    style_ = style;\n}\n\nbool AxisHoverController::updateFromCursorPx (float cursorPosPx,\n                                               float axisLengthPx,\n                                               const AxisMapping& mapping,\n                                               const juce::Array<AxisTick>& ticks)\n{\n    // Clamp cursorPosPx into [0..axisLengthPx]\n    const float clampedPosPx = juce::jlimit (0.0f, axisLengthPx, cursorPosPx);\n    \n    // Hit test using AxisInteraction\n    const AxisHitTest hit = AxisInteraction::hitTest (clampedPosPx, axisLengthPx, mapping, ticks, style_.snap);\n    \n    // Build new state\n    AxisHoverState newState;\n    newState.active = hit.active;\n    newState.cursorPosPx = hit.posPx;  // Use resolved position (snapped if applicable)\n    newState.value = hit.snapped ? hit.snappedValue : hit.value;\n    newState.snappedTickIndex = hit.tickIndex;\n    \n    // Change detection: compare old/new with epsilon\n    bool changed = false;\n    \n    // Active state: exact bool comparison\n    if (newState.active != state_.active)\n        changed = true;\n    \n    // Position: epsilon comparison\n    if (std::abs (newState.cursorPosPx - state_.cursorPosPx) > style_.epsPosPx)\n        changed = true;\n    \n    // Value: epsilon comparison\n    if (std::abs (newState.value - state_.value) > style_.epsValue)\n        changed = true;\n    \n    // Tick index: exact int comparison\n    if (newState.snappedTickIndex != state_.snappedTickIndex)\n        changed = true;\n    \n    // Update state if changed\n    if (changed)\n        state_ = newState;\n    \n    return changed;\n}\n\nbool AxisHoverController::deactivate()\n{\n    if (! state_.active)\n        return false;\n    \n    state_.active = false;\n    state_."
  },
  {
    "algorithm_name": "FocusRing",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#include <mdsp_ui/FocusRing.h>\n"
  },
  {
    "algorithm_name": "SeriesRenderer",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#include <mdsp_ui/SeriesRenderer.h>\n#include <algorithm>\n#include <cmath>\n#include <juce_core/juce_core.h>\n\nnamespace mdsp_ui\n{\n\nstatic inline float clampAlpha (float alpha) noexcept\n{\n    return std::clamp (alpha, 0.0f, 1.0f);\n}\n\nSeriesStats SeriesRenderer::drawPathFromPoints (juce::Graphics& g,\n                                                 const juce::Rectangle<float>& plot,\n                                                 const Theme& theme,\n                                                 const juce::Point<float>* points,\n                                                 int numPoints,\n                                                 juce::Colour colour,\n                                                 const SeriesStyle& style)\n{\n    SeriesStats stats;\n    stats.inputPoints = numPoints;\n\n    if (numPoints < 2 || plot.isEmpty() || points == nullptr)\n    {\n        stats.outputPoints = 0;\n        return stats;\n    }\n\n    juce::Path path;\n    bool pathStarted = false;\n    float lastX = 0.0f;\n    float lastY = 0.0f;\n    bool hasLastPoint = false;\n    int outputCount = 0;\n\n    for (int i = 0; i < numPoints; ++i)\n    {\n        const float x = points[i].x;\n        const float y = points[i].y;\n\n        // Skip NaN/Inf points\n        if (! std::isfinite (x) || ! std::isfinite (y))\n        {\n            pathStarted = false;\n            hasLastPoint = false;\n            continue;\n        }\n\n#if JUCE_DEBUG\n        // Guard: Simple decimation assumes roughly non-decreasing X progression.\n        // Small negative jitter can happen due to mapping/rounding; only flag meaningful backtracking.\n        const float xBacktrackTol = std::max (style.minXStepPx, 0.25f); // px tolerance for debug guard\n\n        if (hasLastPoint && std::isfinite (lastX) && (x + xBacktrackTol) < lastX)\n        {\n            // Non-monotonic X detected - OK, but may cause visual artifacts with simple decimation.\n            // Consider using Envelope mode if this triggers in normal operation.\n           "
  },
  {
    "algorithm_name": "HoverPairController",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#include <mdsp_ui/HoverPairController.h>\n\nnamespace mdsp_ui\n{\n\nHoverPairController::HoverPairController (const AxisHoverControllerStyle& style)\n    : x_ (style)\n    , y_ (style)\n{\n}\n\nvoid HoverPairController::setStyle (const AxisHoverControllerStyle& style)\n{\n    x_.setStyle (style);\n    y_.setStyle (style);\n}\n\nbool HoverPairController::updateFromCursorPx (float cursorXpx,\n                                                float cursorYpx,\n                                                float plotWidthPx,\n                                                float plotHeightPx,\n                                                const AxisMapping& xMapping,\n                                                const juce::Array<AxisTick>& xTicks,\n                                                const AxisSnapOptions& xSnap,\n                                                const AxisMapping& yMapping,\n                                                const juce::Array<AxisTick>& yTicks,\n                                                const AxisSnapOptions& ySnap)\n{\n    // Update X-axis controller\n    bool xChanged = x_.updateFromCursorPx (cursorXpx, plotWidthPx, xMapping, xTicks);\n    \n    // Update Y-axis controller\n    // Note: Y-axis typically increases downward in screen coordinates, but mapping may invert\n    // The controller handles clamping and hit testing internally\n    bool yChanged = y_.updateFromCursorPx (cursorYpx, plotHeightPx, yMapping, yTicks);\n    \n    // Update combined state\n    state_.x = x_.state();\n    state_.y = y_.state();\n    \n    return xChanged || yChanged;\n}\n\nbool HoverPairController::deactivate()\n{\n    bool xChanged = x_.deactivate();\n    bool yChanged = y_.deactivate();\n    \n    // Update combined state\n    state_.x = x_.state();\n    state_.y = y_.state();\n    \n    return xChanged || yChanged;\n}\n\nconst HoverPairState& HoverPairController::state() const noexcept\n{\n    return state_;\n}\n\n} // namespace mdsp_ui\n"
  },
  {
    "algorithm_name": "BarsRenderer",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#include <mdsp_ui/BarsRenderer.h>\n#include <mdsp_ui/Theme.h>\n#include <algorithm>\n#include <cmath>\n\nnamespace mdsp_ui\n{\n\n    BarsResult BarsRenderer::drawBars (\n        juce::Graphics& g,\n        const juce::Rectangle<int>& plotBounds,\n        const Theme& /* theme */,\n        const float* xLeftPx,\n        const float* xRightPx,\n        const float* yTopPx,\n        int count,\n        float baselineYPx,\n        juce::Colour fillColour,\n        const BarsStyle& style)\n    {\n        BarsResult result;\n        \n        if (count <= 0 || ! xLeftPx || ! xRightPx || ! yTopPx)\n            return result;\n        \n        // Clamp alpha to [0..1]\n        const float fillAlpha = juce::jlimit (0.0f, 1.0f, style.fillAlpha);\n        const float strokeAlpha = juce::jlimit (0.0f, 1.0f, style.strokeAlpha);\n        \n        // Set up clipping if requested\n        juce::Graphics::ScopedSaveState clipState (g);\n        if (style.clipToPlot)\n        {\n            g.reduceClipRegion (plotBounds);\n        }\n        \n        // Prepare fill colour\n        const juce::Colour fillCol = fillColour.withAlpha (fillAlpha);\n        \n        // Prepare stroke colour (if enabled)\n        juce::Colour strokeCol;\n        if (strokeAlpha > 0.0f)\n        {\n            strokeCol = fillColour.withAlpha (strokeAlpha);\n        }\n        \n        const float plotLeft = static_cast<float> (plotBounds.getX());\n        const float plotRight = static_cast<float> (plotBounds.getRight());\n        const float plotTop = static_cast<float> (plotBounds.getY());\n        const float plotBottom = static_cast<float> (plotBounds.getBottom());\n        \n        // Draw each bar\n        for (int i = 0; i < count; ++i)\n        {\n            float xLeft = xLeftPx[i];\n            float xRight = xRightPx[i];\n            float yTop = yTopPx[i];\n            \n            // Clamp X coordinates to plot bounds\n            xLeft = juce::jlimit (plotLeft, plotRight, xLeft);\n            xRight = juce::jlimit (plotLeft, plotRight, xRight"
  },
  {
    "algorithm_name": "ValueReadoutRenderer",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#include <mdsp_ui/ValueReadoutRenderer.h>\n#include <mdsp_ui/Theme.h>\n#include <mdsp_ui/PlotFrameRenderer.h>\n#include <mdsp_ui/TextOverlayRenderer.h>\n#include <juce_graphics/juce_graphics.h>\n#include <algorithm>\n#include <cmath>\n\nnamespace mdsp_ui\n{\n    namespace\n    {\n        constexpr float kInsetPx = 8.0f; // constant inset from plot edge\n    }\n\n    ValueReadoutResult ValueReadoutRenderer::draw (\n        juce::Graphics& g,\n        const juce::Rectangle<int>& plotBounds,\n        const Theme& theme,\n        const ValueReadoutLine* lines,\n        int numLines,\n        const ValueReadoutStyle& style)\n    {\n        if (numLines <= 0 || !lines)\n        {\n            ValueReadoutResult result;\n            return result;\n        }\n        \n        // Clamp alphas\n        const float frameFillAlphaClamped = juce::jlimit (0.0f, 1.0f, style.frameFillAlpha);\n        const float frameBorderAlphaClamped = juce::jlimit (0.0f, 1.0f, style.frameBorderAlpha);\n        const float textAlphaClamped = juce::jlimit (0.0f, 1.0f, style.textAlpha);\n        const float disabledTextAlphaClamped = juce::jlimit (0.0f, 1.0f, style.disabledTextAlpha);\n        \n        // Set font once for measurement\n        const juce::Font font (juce::FontOptions().withHeight (style.fontHeightPx));\n        g.setFont (font);\n        \n        // Measure text widths to compute frame width\n        float maxLineWidth = 0.0f;\n        int enabledCount = 0;\n        \n        for (int i = 0; i < numLines; ++i)\n        {\n            if (!lines[i].enabled)\n                continue;\n            \n            ++enabledCount;\n            \n            float lineWidth = 0.0f;\n            if (lines[i].left.isEmpty())\n            {\n                // Single right value spanning full width\n                juce::GlyphArrangement glyphs;\n                glyphs.addFittedText (font, lines[i].right, 0.0f, 0.0f, 10000.0f, style.fontHeightPx, juce::Justification::left, 1);\n                lineWidth = glyphs.getBoundingBox (0, -1, true).g"
  },
  {
    "algorithm_name": "AxisRenderer",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#include <mdsp_ui/AxisRenderer.h>\n#include <algorithm>\n\nnamespace mdsp_ui\n{\n\nstatic inline float clampAlpha (float alpha) noexcept\n{\n    return std::clamp (alpha, 0.0f, 1.0f);\n}\n\nvoid AxisRenderer::draw (juce::Graphics& g,\n                         const juce::Rectangle<int>& plotBounds,\n                         const Theme& theme,\n                         const juce::Array<AxisTick>& ticks,\n                         AxisEdge edge,\n                         const AxisStyle& style)\n{\n    // Guardrails\n    if (plotBounds.isEmpty() || ticks.isEmpty() || style.tickThickness <= 0.0f)\n        return;\n\n    const float tickAlphaClamped = clampAlpha (style.tickAlpha);\n    const int plotLeft = plotBounds.getX();\n    const int plotTop = plotBounds.getY();\n    const int plotRight = plotBounds.getRight();\n    const int plotBottom = plotBounds.getBottom();\n\n    // Set label font and color (only if labels will be drawn)\n    float labelAlphaClamped = 0.0f;\n    if (! style.ticksOnly)\n    {\n        labelAlphaClamped = clampAlpha (style.labelAlpha);\n        g.setFont (juce::Font (juce::FontOptions().withHeight (style.labelFontHeight)));\n    }\n\n    switch (edge)\n    {\n        case AxisEdge::Bottom:\n        {\n            // Ticks extend upward from bottom edge (into plot bounds)\n            const float yTickStart = static_cast<float> (plotBottom);\n            \n            for (const auto& tick : ticks)\n            {\n                const float xPos = static_cast<float> (plotLeft) + tick.posPx;\n                \n                // Clip check\n                if (style.clipTicksToPlot && (xPos < static_cast<float> (plotLeft) || xPos > static_cast<float> (plotRight)))\n                    continue;\n                \n                // Determine tick length: if label is empty, treat as minor tick\n                const bool isMajor = tick.major && tick.label.isNotEmpty();\n                const float tickLength = isMajor ? style.majorTickLengthPx : style.minorTickLengthPx;\n                const floa"
  },
  {
    "algorithm_name": "ChoiceRow",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#include <mdsp_ui/controls/ChoiceRow.h>\n\nnamespace mdsp_ui\n{\n\nChoiceRow::ChoiceRow (UiContext& ui, const juce::String& labelText, juce::ComboBox& combo)\n    : ui_ (ui),\n      combo_ (combo)\n{\n    const auto& theme = ui_.theme();\n    const auto& type = ui_.type();\n    \n    label_.setText (labelText, juce::dontSendNotification);\n    label_.setFont (type.labelSmallFont());\n    label_.setJustificationType (juce::Justification::centredLeft);\n    label_.setColour (juce::Label::textColourId, theme.grey);\n}\n\nvoid ChoiceRow::attachToParent (juce::Component& parent)\n{\n    parent.addAndMakeVisible (label_);\n    parent.addAndMakeVisible (combo_);\n}\n\nvoid ChoiceRow::layout (juce::Rectangle<int> bounds, int& y)\n{\n    const auto& m = ui_.metrics();\n    label_.setBounds (bounds.getX(), y, bounds.getWidth(), m.secondaryHeight);\n    y += m.secondaryHeight;\n    combo_.setBounds (bounds.getX(), y, bounds.getWidth(), m.comboH);\n    y += m.comboH + m.gapSmall;\n}\n\n} // namespace mdsp_ui\n"
  },
  {
    "algorithm_name": "ToggleRow",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#include <mdsp_ui/controls/ToggleRow.h>\n\nnamespace mdsp_ui\n{\n\nToggleRow::ToggleRow (UiContext& ui, const juce::String& labelText, juce::ToggleButton& toggle)\n    : ui_ (ui),\n      toggle_ (toggle)\n{\n    const auto& theme = ui_.theme();\n    const auto& type = ui_.type();\n    label_.setText (labelText, juce::dontSendNotification);\n    label_.setFont (type.labelSmallFont());\n    label_.setJustificationType (juce::Justification::centredLeft);\n    label_.setColour (juce::Label::textColourId, theme.grey);\n}\n\nvoid ToggleRow::attachToParent (juce::Component& parent)\n{\n    parent.addAndMakeVisible (label_);\n    parent.addAndMakeVisible (toggle_);\n}\n\nvoid ToggleRow::layout (juce::Rectangle<int> bounds, int& y)\n{\n    const auto& m = ui_.metrics();\n    label_.setBounds (bounds.getX(), y, bounds.getWidth(), m.secondaryHeight);\n    y += m.secondaryHeight;\n    toggle_.setBounds (bounds.getX(), y, m.buttonSmallW, m.buttonSmallH);\n    y += m.buttonSmallH + m.gapSmall;\n}\n\n} // namespace mdsp_ui\n"
  },
  {
    "algorithm_name": "SectionHeader",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#include <mdsp_ui/controls/SectionHeader.h>\n\nnamespace mdsp_ui\n{\n\nSectionHeader::SectionHeader (UiContext& ui, const juce::String& text)\n    : ui_ (ui)\n{\n    const auto& theme = ui_.theme();\n    const auto& type = ui_.type();\n    \n    label_.setText (text, juce::dontSendNotification);\n    label_.setFont (type.sectionTitleFont());\n    label_.setJustificationType (juce::Justification::centredLeft);\n    label_.setColour (juce::Label::textColourId, theme.lightGrey);\n}\n\nvoid SectionHeader::attachToParent (juce::Component& parent)\n{\n    parent.addAndMakeVisible (label_);\n}\n\nvoid SectionHeader::layout (juce::Rectangle<int> bounds, int& y)\n{\n    const auto& m = ui_.metrics();\n    label_.setBounds (bounds.getX(), y, bounds.getWidth(), m.titleHeight);\n    y += m.titleHeight + m.titleSecondaryGap;\n}\n\n} // namespace mdsp_ui\n"
  },
  {
    "algorithm_name": "SliderRow",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#include <mdsp_ui/controls/SliderRow.h>\n\nnamespace mdsp_ui\n{\n\nSliderRow::SliderRow (UiContext& ui,\n                      const juce::String& labelText,\n                      juce::Slider& slider,\n                      double minValue,\n                      double maxValue,\n                      double stepValue,\n                      double defaultValue)\n    : ui_ (ui),\n      slider_ (slider)\n{\n    const auto& theme = ui_.theme();\n    const auto& type = ui_.type();\n    const auto& m = ui_.metrics();\n    \n    label_.setText (labelText, juce::dontSendNotification);\n    label_.setFont (type.labelSmallFont());\n    label_.setJustificationType (juce::Justification::centredLeft);\n    label_.setColour (juce::Label::textColourId, theme.grey);\n    \n    slider_.setSliderStyle (juce::Slider::LinearHorizontal);\n    slider_.setTextBoxStyle (juce::Slider::TextBoxRight, false, m.sliderTextBoxW, m.sliderTextBoxH);\n    slider_.setRange (minValue, maxValue, stepValue);\n    slider_.setValue (defaultValue, juce::dontSendNotification);\n}\n\nvoid SliderRow::attachToParent (juce::Component& parent)\n{\n    parent.addAndMakeVisible (label_);\n    parent.addAndMakeVisible (slider_);\n}\n\nvoid SliderRow::layout (juce::Rectangle<int> bounds, int& y)\n{\n    const auto& m = ui_.metrics();\n    label_.setBounds (bounds.getX(), y, bounds.getWidth(), m.secondaryHeight);\n    y += m.secondaryHeight;\n    slider_.setBounds (bounds.getX(), y, bounds.getWidth(), m.sliderH);\n    y += m.sliderH + m.gapSmall;\n}\n\n} // namespace mdsp_ui\n"
  },
  {
    "algorithm_name": "CMakeCXXCompilerId",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DE"
  },
  {
    "algorithm_name": "CMakeCXXCompilerId",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DE"
  },
  {
    "algorithm_name": "MainView",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#include \"MainView.h\"\n#include <mdsp_ui/UiContext.h>\n\n//==============================================================================\nMainView::MainView (mdsp_ui::UiContext& ui)\n    : ui_ (ui)\n    // Initialize child components here, passing ui_ by reference:\n    // , header_ (ui_)\n    // , footer_ (ui_)\n    // , rail_ (ui_)\n    // , center_ (ui_)\n{\n    // Add child components as visible:\n    // addAndMakeVisible (header_);\n    // addAndMakeVisible (footer_);\n    // addAndMakeVisible (rail_);\n    // addAndMakeVisible (center_);\n}\n\nMainView::~MainView()\n{\n    shutdown();\n}\n\nvoid MainView::shutdown()\n{\n    if (isShutdown_)\n        return;\n\n    isShutdown_ = true;\n\n    // Stop any timers here\n    // Clear any callbacks here\n    // Detach any listeners here\n}\n\n//==============================================================================\nvoid MainView::paint (juce::Graphics& g)\n{\n    const auto& theme = ui_.theme();\n\n    // Background from shared theme\n    g.fillAll (theme.background);\n\n#if JUCE_DEBUG\n    // Debug overlay: visualize layout regions\n    g.setFont (juce::Font (juce::FontOptions().withHeight (10.0f)));\n\n    // Header\n    g.setColour (juce::Colours::yellow.withAlpha (0.5f));\n    g.drawRect (debugHeader_.toFloat(), 1.5f);\n    g.drawText (\"Header\", debugHeader_.reduced (4), juce::Justification::topLeft);\n\n    // Footer\n    g.setColour (juce::Colours::cyan.withAlpha (0.5f));\n    g.drawRect (debugFooter_.toFloat(), 1.5f);\n    g.drawText (\"Footer\", debugFooter_.reduced (4), juce::Justification::topLeft);\n\n    // Center\n    g.setColour (juce::Colours::green.withAlpha (0.5f));\n    g.drawRect (debugCenter_.toFloat(), 1.5f);\n    g.drawText (\"Center\", debugCenter_.reduced (4), juce::Justification::topLeft);\n\n    // Control Rail\n    g.setColour (juce::Colours::magenta.withAlpha (0.5f));\n    g.drawRect (debugRail_.toFloat(), 1.5f);\n    g.drawText (\"Rail\", debugRail_.reduced (4), juce::Justification::topLeft);\n#endif\n}\n\nvoid MainView::resized()\n{\n    const auto& m = u"
  },
  {
    "algorithm_name": "PluginEditor",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\n\n#include <juce_audio_processors/juce_audio_processors.h>\n#include <juce_gui_basics/juce_gui_basics.h>\n#include <mdsp_ui/UiContext.h>\n#include <mdsp_ui/ThemeVariant.h>\n\n#include \"PluginProcessor.h\"\n#include \"ui/MainView.h\"\n\n//==============================================================================\n/**\n    PluginEditor \u2014 Audio processor editor with MelechDSP design system.\n\n    This is a TEMPLATE. Rename the class and customize for your plugin.\n    \n    Key responsibilities:\n    - Own the single UiContext instance\n    - Own the window size and resize limits\n    - Contain MainView as the sole child component\n    \n    Layout rules:\n    - Only PluginEditor calls setSize()\n    - Only PluginEditor calls setResizeLimits()\n    - MainView receives full bounds via setBounds()\n*/\nclass TemplateAudioProcessorEditor : public juce::AudioProcessorEditor\n{\npublic:\n    TemplateAudioProcessorEditor (TemplateAudioProcessor& p);\n    ~TemplateAudioProcessorEditor() override;\n\n    void paint (juce::Graphics& g) override;\n    void resized() override;\n\nprivate:\n    TemplateAudioProcessor& audioProcessor_;\n    \n    //==========================================================================\n    // UI CONTEXT \u2014 Single instance, owned here, passed by reference to all UI\n    //==========================================================================\n    mdsp_ui::UiContext ui_;\n    \n    //==========================================================================\n    // MAIN VIEW \u2014 Contains all UI layout and components\n    //==========================================================================\n    MainView mainView_;\n\n    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (TemplateAudioProcessorEditor)\n};\n"
  },
  {
    "algorithm_name": "PlaceholderRegion",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\n\n#include <juce_gui_basics/juce_gui_basics.h>\n#include <mdsp_ui/UiContext.h>\n\n/**\n    PlaceholderRegion \u2014 A generic placeholder component for prototyping layout.\n    \n    Use this to fill layout regions (Header, Footer, Center, Rail)\n    before implementing the actual components.\n    \n    Displays:\n    - Diagonal crosshatch pattern\n    - Region name\n    - Current bounds size\n*/\nclass PlaceholderRegion : public juce::Component\n{\npublic:\n    PlaceholderRegion (mdsp_ui::UiContext& ui, const juce::String& name)\n        : ui_ (ui), name_ (name)\n    {\n    }\n\n    void paint (juce::Graphics& g) override\n    {\n        const auto& theme = ui_.theme();\n        const auto& type = ui_.type();\n        const auto& m = ui_.metrics();\n\n        // Background with border\n        g.setColour (theme.background.withAlpha (0.5f));\n        g.fillAll();\n        g.setColour (theme.borderDivider);\n        g.drawRect (getLocalBounds(), 1);\n\n        // Crosshatch pattern\n        g.setColour (theme.textMuted.withAlpha (0.1f));\n        const int space = 20;\n        for (int x = -getHeight(); x < getWidth(); x += space)\n            g.drawLine ((float)x, 0.0f, (float)(x + getHeight()), (float)getHeight());\n\n        // Text label (Name + Size)\n        auto text = name_ + \"\\n\" + \n                    juce::String (getWidth()) + \"x\" + juce::String (getHeight());\n                    \n        g.setColour (theme.text);\n        g.setFont (type.labelFont());\n        g.drawText (text, getLocalBounds(), juce::Justification::centred);\n    }\n\nprivate:\n    mdsp_ui::UiContext& ui_;\n    juce::String name_;\n};\n"
  },
  {
    "algorithm_name": "MainView",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#pragma once\n\n#include <juce_gui_basics/juce_gui_basics.h>\n#include <mdsp_ui/UiContext.h>\n\n//==============================================================================\n/**\n    MainView \u2014 Pure layout container for plugin UI.\n    \n    This is a TEMPLATE. Copy and customize for your plugin.\n    \n    Layout regions (customize as needed):\n    - Header bar (top)\n    - Footer bar (bottom)\n    - Center view (main content area)\n    - Control rail (left or right sidebar)\n    - Meter rails (optional, left/right of center)\n    \n    Rules:\n    - No DSP logic in this class\n    - No parameter ownership (use ControlBinder pattern)\n    - Layout uses ui_.metrics() only \u2014 no magic numbers\n    - Never call setSize() \u2014 parent owns size\n*/\nclass MainView : public juce::Component\n{\npublic:\n    explicit MainView (mdsp_ui::UiContext& ui);\n    ~MainView() override;\n\n    void paint (juce::Graphics& g) override;\n    void resized() override;\n\n    /** \n        Shutdown: Stop timers, clear callbacks, detach listeners.\n        Called from PluginEditor destructor before component destruction.\n        Safe to call multiple times.\n    */\n    void shutdown();\n\nprivate:\n    bool isShutdown_ = false;\n    mdsp_ui::UiContext& ui_;  // Reference to shared UiContext from PluginEditor\n\n    //==========================================================================\n    // LAYOUT REGIONS\n    // Uncomment and customize the regions you need.\n    //==========================================================================\n    \n    // HeaderBar header_;      // Top bar (title, controls)\n    // FooterBar footer_;      // Bottom bar (status)\n    // ControlRail rail_;      // Sidebar (controls)\n    // CenterView center_;     // Main content area\n    // MeterRail inputMeters_; // Optional: left meter strip\n    // MeterRail outputMeters_;// Optional: right meter strip\n\n    //==========================================================================\n    // DEBUG: Layout debug rectangles (remove in production)\n    /"
  },
  {
    "algorithm_name": "PluginEditor",
    "processing_domain": "ControlRate",
    "latency_samples": 0,
    "simd_optimized": false,
    "code_snippet": "#include \"PluginProcessor.h\"\n#include \"PluginEditor.h\"\n\n//==============================================================================\n// CUSTOMIZE THESE VALUES FOR YOUR PLUGIN\n//==============================================================================\nnamespace\n{\n    // Base window size (pixels)\n    constexpr int kBaseWidth  = 600;\n    constexpr int kBaseHeight = 400;\n\n    // Resize limits (min/max)\n    constexpr int kMinWidth  = 400;\n    constexpr int kMinHeight = 300;\n    constexpr int kMaxWidth  = 1200;\n    constexpr int kMaxHeight = 800;\n}\n\n//==============================================================================\nTemplateAudioProcessorEditor::TemplateAudioProcessorEditor (TemplateAudioProcessor& p)\n    : AudioProcessorEditor (&p),\n      audioProcessor_ (p),\n      ui_ (mdsp_ui::ThemeVariant::Dark),  // Choose Dark or Light theme\n      mainView_ (ui_)                      // Pass UiContext by reference\n{\n    // Add MainView as the sole child component\n    addAndMakeVisible (mainView_);\n\n    // Set window size and resize behavior\n    // NOTE: Only PluginEditor should call setSize/setResizeLimits\n    setResizable (true, true);\n    setResizeLimits (kMinWidth, kMinHeight, kMaxWidth, kMaxHeight);\n    setSize (kBaseWidth, kBaseHeight);\n}\n\nTemplateAudioProcessorEditor::~TemplateAudioProcessorEditor()\n{\n    // Shutdown MainView BEFORE destruction to stop timers and clear callbacks\n    mainView_.shutdown();\n\n    // Clear look and feel if set\n    setLookAndFeel (nullptr);\n}\n\n//==============================================================================\nvoid TemplateAudioProcessorEditor::paint (juce::Graphics& g)\n{\n    // Background from look and feel (or use ui_.theme().background directly)\n    g.fillAll (getLookAndFeel().findColour (juce::ResizableWindow::backgroundColourId));\n}\n\nvoid TemplateAudioProcessorEditor::resized()\n{\n    // MainView fills entire editor bounds\n    // Layout is handled inside MainView::resized()\n    mainView_.setBounds (getLocalBoun"
  }
]